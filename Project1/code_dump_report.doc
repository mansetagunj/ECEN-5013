/**
 * @brief 
 * 
 * @file socket_task.h
 * @author Gunj Manseta
 * @date 2018-03-09
 */

#ifndef SOCKET_TASK_H
#define SOCKET_TASK_H

#include <signal.h>

sig_atomic_t socketTask_continue;

/**
 * @brief 
 * 
 * @param threadparam 
 * @return void* 
 */
void* socket_task_callback(void* threadparam);



#endif/*
 * @File posixTimer.h
 *
 * @Created on: 18-Feb-2018
 * @Author: Gunj Manseta
 */

#ifndef POSIX_TIMER_H
#define POSIX_TIMER_H


#include <time.h>
#include <linux/types.h>
#include <stdint.h>
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>


#define MICROSEC	(1000000)

/**
 * @brief REgsiter the timer handler 
 * 
 * @param timer_id 
 * @param timer_handler 
 * @param handlerArgs 
 * @return int 
 */
int register_timer(timer_t *timer_id, void (*timer_handler)(union sigval), void *handlerArgs);


/**
 * @brief Starts the timer 
 * 
 * @param timer_id 
 * @param time_usec 
 * @param oneshot 
 * @return int 
 */
int start_timer(timer_t timer_id , uint64_t time_usec, uint8_t oneshot);

/**
 * @brief Stops the timer 
 * 
 * @param timer_id 
 * @return int 
 */
int stop_timer(timer_t timer_id);

/**
 * @brief Destroys the timer 
 * 
 * @param timer_id 
 * @return int 
 */
int delete_timer(timer_t timer_id);

#endif
/**
 * @brief 
 * 
 * @file sensor_common_object.h
 * @author Gunj Manseta
 * @date 2018-03-11
 */
#ifndef SENS_COMM_OBJ_H
#define SENS_COMM_OBJ_H

#include <stdint.h>
#include <semaphore.h>


/***
 * Required for remote client server communication 
 **/
typedef enum
{
    GET_TEMP_C,
    GET_TEMP_F,
    GET_TEMP_K,
    GET_LUX,
    GET_DAY_NIGHT,
    GET_FUNC,
    CONN_CLOSE_REQ,
    CONN_CLOSE_RSP,
    CONN_KILL_APP_REQ,
    CONN_KILL_APP_RSP

}REMOTE_REQRSP_ID;

typedef struct
{
    REMOTE_REQRSP_ID request_id;

}REMOTE_REQUEST_T;

typedef struct
{
    REMOTE_REQRSP_ID rsp_id;
    union data{
        float floatingData;
        uint8_t isNight;
    }data;
    char metadata[20];

}REMOTE_RESPONSE_T;



typedef uint8_t*    P_BUFF_T;
typedef uint8_t     DEV_REG_T;
typedef size_t      BUFF_LEN_T;

typedef enum   
{
    ASYNC = 0,
    SYNC  = 1
}SYNC_TYPE_T;

typedef struct
{
    SYNC_TYPE_T is_sync;   
    sem_t       *sync_semaphore;
    DEV_REG_T   dev_addr;
    P_BUFF_T    *reg_value;
    BUFF_LEN_T  buffLen;

}OBJECT_PACKET_T;

#define SENSOR_MAKE_PACKET_SYNCTYPE(p_packet, p_sem) { p_packet->is_sync = SYNC; if(NULL != p_sem){p_packet->sync_semaphore = p_sem;} }

#define SENSOR_MAKE_PACKET_ASYNCTYPE(p_packet)   {p_packet->is_sync = ASYNC; p_packet->sync_semaphore = NULL;}

#define SENSOR_MAKE_PACKET_RW_1DATA(p_packet)   (p_packet->buffLen = 1)
#define SENSOR_MAKE_PACKET_RW_2DATA(p_packet)   (p_packet->buffLen = 2)

static inline int  SENSOR_FILL_OBJECT_DATA(OBJECT_PACKET_T *packet, DEV_REG_T devaddr, P_BUFF_T *val, BUFF_LEN_T len)
{
    packet->dev_addr = devaddr;
    packet->reg_value = val;
    packet->buffLen = len;
}


#endif/**
 * @brief 
 * 
 * @file light_sensor_task.h
 * @author Gunj Manseta
 * @date 2018-03-11
 */

#ifndef LIGHTSENSOR_TASK_H
#define LIGHTSENSOR_TASK_H

#include <stdlib.h>
#include <errno.h>
#include <string.h>

#include <mqueue.h>
#include "common_helper.h"
#include "my_time.h"
#include "error_data.h"
#include "sensor_common_object.h"

//#define LightT_MSG_SIZE 40

//typedef char LIGHT_TASK_MSGDATA_T;


typedef enum
{
    DAY = 0,
    NIGHT = 1
}DAY_STATE_T;

typedef enum
{
    LIGHT_MSG_TASK_STATUS,
    LIGHT_MSG_TASK_GET_STATE,
    LIGHT_MSG_TASK_READ_DATA,
    LIGHT_MSG_TASK_WRITE_CMD,
    LIGHT_MSG_TASK_POWERDOWN,
    LIGHT_MSG_TASK_POWERUP,
    LIGHT_MSG_TASK_EXIT,
}LIGHTTASKQ_MSGID_T;


typedef struct 
{
    LIGHTTASKQ_MSGID_T msgID;
    TASK_IDENTIFIER_T sourceID;
    OBJECT_PACKET_T packet;
    //LOGGER_TASK_MSGDATA_T msgData[LightT_MSG_SIZE];

}LIGHTTASKQ_MSG_T;


/**
 * @brief Defines a light struct with the name given and params with some default values
 * 
 */
#define DEFINE_LIGHT_STRUCT(name,msgId,sourceId) \
    LIGHTTASKQ_MSG_T name = {      \
        .msgID      = msgId,        \
        .sourceID   = sourceId,     \
        .packet     = {0}           \
    };                               

/**
 * @brief Get the Handle LightTaskQueue object
 * 
 * @return mqd_t 
 */
mqd_t getHandle_LightTaskQueue();

/**
 * @brief 
 * 
*/
#define POST_MESSAGE_LIGHTTASK(p_lightstruct)  \
    do{ \
        __POST_MESSAGE_LIGHTTASK(getHandle_LightTaskQueue(), p_lightstruct, sizeof(*p_lightstruct),20); \
    }while(0)

/**
 * @brief 
 * 
 */
#define POST_MESSAGE_LIGHTTASK_EXIT(p_lightstruct)  \
    do{ \
        __POST_MESSAGE_LIGHTTASK(getHandle_LightTaskQueue(), p_lightstruct, sizeof(*p_lightstruct),50); \
    }while(0)

/**
 * @brief 
 * 
 * @param queue 
 * @param lightstruct 
 * @param light_struct_size 
 */
static inline void __POST_MESSAGE_LIGHTTASK(mqd_t queue, const LIGHTTASKQ_MSG_T *lightstruct, size_t light_struct_size, int prio)
{
    if(-1 == mq_send(queue, (const char*)lightstruct, light_struct_size, prio))
    {
        LOG_STDOUT(ERROR "LIGHT:MQ_SEND:%s\n",strerror(errno));
    }
}

/**
 * @brief Get the LightTask state object MT-safe
 * 
 * @return DAY_STATE_T 
 */
DAY_STATE_T getLightTask_state();

/**
 * @brief Get the LightTask lux object. MT-safe as it calls a MT-safe function within
 * 
 * @return float 
 */
float getLightTask_lux();

/**
 * @brief Entry point of the light task thread
 * 
 * @param threadparam 
 * @return void* 
 */
void* light_task_callback(void *threadparam);

#endif/**
 * @brief 
 * 
 * @file main_task.h
 * @author Gunj Manseta
 * @date 2018-03-09
 */

#ifndef MAIN_TASK_H
#define MAIN_TASK_H

#include <mqueue.h>
#include <errno.h>
#include <string.h>
#include "common_helper.h"
#include "error_data.h"


#define MT_MSG_SIZE 20

typedef char MAINT_TASK_MSGDATA_T;

typedef enum
{
    MT_MSG_STATUS_RSP,
    MT_MSG_INIT_SUCCESS_RSP,

}MAINTASKQ_MSGID_T;

typedef struct 
{
    MAINTASKQ_MSGID_T msgID;
    TASK_IDENTIFIER_T sourceID;
    MAINT_TASK_MSGDATA_T msgData[MT_MSG_SIZE];

}MAINTASKQ_MSG_T;


/**
 * @brief Defines a Main task queue struct with the name given and params with some default values
 * 
 */
#define DEFINE_MAINTASK_STRUCT(name,msgId,sourceId) \
    MAINTASKQ_MSG_T name = {      \
        .msgID      = msgId,        \
        .sourceID   = sourceId,     \
        .msgData    = {0}           \
    };                              

/**
 * @brief 
 * 
 */
#define POST_MESSAGE_MAINTASK(p_maintaskstruct, format, ...)  \
    do{ \
        snprintf((p_maintaskstruct)->msgData,sizeof((p_maintaskstruct)->msgData),format, ##__VA_ARGS__);   \
        __POST_MESSAGE_MAINTASK(getHandle_MainTaskQueue(), p_maintaskstruct, sizeof(*p_maintaskstruct)); \
    }while(0)

/**
 * @brief Post message to the main task using the main task queue handle and giving struct
 * 
 * @param queue 
 * @param main_task_struct 
 * @param maintask_struct_size 
 */
static inline void __POST_MESSAGE_MAINTASK(mqd_t queue, const MAINTASKQ_MSG_T *main_task_struct, size_t maintask_struct_size)
{
    if(-1 == mq_send(queue, (const char*)main_task_struct, maintask_struct_size, 20))
    {
        LOG_STDOUT(ERROR "MAIN:MQ_SEND:%s\n",strerror(errno));
    }
}

/**
 * @brief Get the Handle MainTaskQueue object
 * 
 * @return mqd_t 
 */
mqd_t getHandle_MainTaskQueue();

/**
 * @brief entry point for the main task
 * 
 * @return int 
 */
int main_task_entry();  

#endif/*
 * @File my_time.h
 *
 * @Created on: 18-Feb-2018
 * @Author: Gunj Manseta
 */
 
#ifndef TIME_H
#define TIME_H

int get_time_string(char *timeString, int len);

#endif
/**
 * @brief 
 * 
 * @file temperature_sensor_task.h
 * @author Gunj Manseta
 * @date 2018-03-11
 */

#ifndef TEMPSENSOR_TASK_H
#define TEMPSENSOR_TASK_H

#include <stdlib.h>
#include <errno.h>
#include <string.h>

#include <mqueue.h>
#include "common_helper.h"
#include "my_time.h"
#include "error_data.h"
#include "sensor_common_object.h"


typedef enum
{
    TEMP_MSG_TASK_STATUS,
    TEMP_MSG_TASK_GET_TEMP,
    TEMP_MSG_TASK_READ_DATA,
    TEMP_MSG_TASK_WRITE_CMD,
    TEMP_MSG_TASK_POWERDOWN,
    TEMP_MSG_TASK_POWERUP,
    TEMP_MSG_TASK_EXIT,

}TEMPERATURETASKQ_MSGID_T;


typedef struct 
{
    TEMPERATURETASKQ_MSGID_T msgID;
    TASK_IDENTIFIER_T sourceID;
    OBJECT_PACKET_T packet;
    //LOGGER_TASK_MSGDATA_T msgData[LightT_MSG_SIZE];

}TEMPERATURETASKQ_MSG_T;


/**
 * @brief Defines a temp struct with the name given and params with some default values
 * 
 */
#define DEFINE_TEMP_STRUCT(name,msgId,sourceId) \
    TEMPERATURETASKQ_MSG_T name = {      \
        .msgID      = msgId,        \
        .sourceID   = sourceId,     \
        .packet     = {0}           \
    };                               

/**
 * @brief Get the Handle TemperatureTaskQueue object
 * 
 * @return mqd_t 
 */
mqd_t getHandle_TemperatureTaskQueue();

/**
 * @brief 
 * 
 */
#define POST_MESSAGE_TEMPERATURETASK(p_tempstruct)  \
    do{  \
        __POST_MESSAGE_TEMPERATURETASK(getHandle_TemperatureTaskQueue(), p_tempstruct, sizeof(*p_tempstruct),20); \
    }while(0)

/**
 * @brief 
 * 
 */
#define POST_MESSAGE_TEMPERATURETASK_EXIT(p_tempstruct)  \
    do{  \
        __POST_MESSAGE_TEMPERATURETASK(getHandle_TemperatureTaskQueue(), p_tempstruct, sizeof(*p_tempstruct),50); \
    }while(0)

/**
 * @brief 
 * 
 * @param queue 
 * @param p_tempstruct 
 * @param temp_struct_size 
 */
static inline void __POST_MESSAGE_TEMPERATURETASK(mqd_t queue, const TEMPERATURETASKQ_MSG_T *p_tempstruct, size_t temp_struct_size, int prio)
{
    if(-1 == mq_send(queue, (const char*)p_tempstruct, temp_struct_size, prio))
    {
        LOG_STDOUT(ERROR "TEMP:MQ_SEND:%s\n",strerror(errno));
    }
}

/**
 * @brief Get the TempTask temperature object MT-safe
 * 
 * @return float 
 */float getTempTask_temperature();

/**
 * @brief Entry point of the temp task thread
 * 
 * @param threadparam 
 * @return void* 
 */
void* temperature_task_callback(void *threadparam);


#endif/*
 * @File my_signals.h
 *
 * @Created on: 18-Feb-2018
 * @Author: Gunj Manseta
 */
 
#ifndef MY_SIGNALS_H
#define MY_SIGNALS_H

#include <sys/types.h>
#include <unistd.h>
#include <signal.h>
#include <stdint.h>
		
#define REG_SIG_USR1	(1<<0)
#define REG_SIG_USR2	(1<<1)
#define REG_SIG_INT		(1<<2)
#define REG_SIG_TERM	(1<<3)
#define REG_SIG_TSTP	(1<<4)
#define REG_SIG_ALL		(0x1F)

typedef uint8_t REG_SIGNAL_FLAG_t ;

/**
 * @brief Register asignal handler for specific signal masks
 * 
 * @param sa 
 * @param handler 
 * @param signalMask 
 * @return int 
 */
int register_signalHandler(struct sigaction *sa, void (*handler)(int), REG_SIGNAL_FLAG_t signalMask);



#endif
/**
 * @brief 
 * 
 * @file logger_task.h
 * @author Gunj Manseta
 * @date 2018-03-09
 */

#ifndef LOGGER_TASK_H
#define LOGGER_TASK_H

#include <stdlib.h>
#include <errno.h>
#include <string.h>

#include <mqueue.h>
#include "common_helper.h"
#include "my_time.h"
#include "error_data.h"


#define LT_MSG_SIZE 40

typedef char LOGGER_TASK_MSGDATA_T;

typedef enum
{
    LT_MSG_TASK_STATUS,
    LT_MSG_LOG,
    LT_MSG_TASK_EXIT
    
}LOGGERTASKQ_MSGID_T;

typedef enum
{
    LOG_ERROR,
    LOG_WARNING,
    LOG_INFO,
    LOG_ALL
    
}LOG_LEVEL_T;

typedef struct 
{
    LOGGERTASKQ_MSGID_T msgID;
    char timestamp[20];
    LOG_LEVEL_T loglevel;
    TASK_IDENTIFIER_T sourceID;
    LOGGER_TASK_MSGDATA_T msgData[LT_MSG_SIZE];

}LOGGERTASKQ_MSG_T;

/**
 * @brief Defines a Log struct with the name given and params with some default values
 * 
 */
#define DEFINE_LOG_STRUCT(name,msgId,sourceId) \
    LOGGERTASKQ_MSG_T name = {      \
        .msgID      = msgId,        \
        .loglevel   = LOG_ALL,      \
        .sourceID   = sourceId,     \
        .timestamp  = {0},          \
        .msgData    = {0}           \
    };                               

/**
 * @brief Set the Log loglevel
 * 
 * @param log_msg 
 * @param loglevel 
 */
static inline void set_Log_loglevel(LOGGERTASKQ_MSG_T *log_msg, LOG_LEVEL_T loglevel)   
{
    log_msg->loglevel = loglevel;
}

/**
 * @brief Set the Log currentTimestamp to the currentTime as "sec.nsec"
 * 
 * @param log_msg 
 */
static inline void set_Log_currentTimestamp(LOGGERTASKQ_MSG_T *log_msg)   
{
    get_time_string(log_msg->timestamp,sizeof(log_msg->timestamp));
}

/**
 * @brief Get the Handle LoggerTaskQueue object
 * 
 * @return mqd_t 
 */
mqd_t getHandle_LoggerTaskQueue();

/**
 * @brief 
 * 
 */
#define POST_MESSAGE_LOGTASK(p_logstruct, format, ...)  \
    do{ \
        snprintf((p_logstruct)->msgData,sizeof((p_logstruct)->msgData),format, ##__VA_ARGS__);   \
        set_Log_currentTimestamp(p_logstruct); \
        __POST_MESSAGE_LOGTASK(getHandle_LoggerTaskQueue(), p_logstruct, sizeof(*p_logstruct), 20); \
    }while(0)

#define POST_MESSAGE_LOGTASK_EXIT(p_logstruct, format, ...)  \
    do{ \
        snprintf((p_logstruct)->msgData,sizeof((p_logstruct)->msgData),format, ##__VA_ARGS__);   \
        set_Log_currentTimestamp(p_logstruct); \
        __POST_MESSAGE_LOGTASK(getHandle_LoggerTaskQueue(), p_logstruct, sizeof(*p_logstruct), 50); \
    }while(0)

/**
 * @brief Post message to the log using the log queue handle and giving log struct
 * 
 * @param queue 
 * @param logstruct 
 * @param log_struct_size 
 */
static inline void __POST_MESSAGE_LOGTASK(mqd_t queue, const LOGGERTASKQ_MSG_T *logstruct, size_t log_struct_size, int prio)
{
    if(-1 == mq_send(queue, (const char*)logstruct, log_struct_size, prio))
    {
        LOG_STDOUT(ERROR "LOGGER:MQ_SEND:%s\n",strerror(errno));
    }
}

/**
 * @brief Entry point of the logger task thread
 * 
 * @param threadparam 
 * @return void* 
 */
void* logger_task_callback(void *threadparam);

#endif/**
 * @brief 
 * 
 * @file readConfiguration.h
 * @author Gunj Manseta
 * @date 2018-03-17
 */

#ifndef READCONIFG_H
#define READCONIFG_H

/**
 * @brief 
 * 
 * @return char* 
 */
char* configdata_getLogpath();

/**
 * @brief 
 * 
 * @return uint32_t 
 */
uint32_t configdata_getSetupTime();

/**
 * @brief 
 * 
 * @return uint32_t 
 */
uint32_t configdata_getAliveTimeout();

/**
 * @brief Should be called in the main task at the beginning
 * 
 * @return int 
 */
int configdata_setup();

/**
 * @brief Should be called at teh end of main task. If not called, memory leak will occur
 * 
 */
void configdata_flush();


#endif/**
 * @brief 
 * 
 * @file common_helper.h
 * @author Gunj Manseta
 * @date 2018-03-09
 */
#ifndef COMMON_HELPER_H
#define COMMON_HELPER_H

#include <mqueue.h>
#include <pthread.h>

#include "posixTimer.h"

#define NUM_CHILD_THREADS 4

typedef enum
{
    LOGGER_TASK_ID,
    TEMPERATURE_TASK_ID,
    SOCKET_TASK_ID,
    LIGHT_TASK_ID,
    MAIN_TASK_ID

}TASK_IDENTIFIER_T;

volatile int aliveStatus[NUM_CHILD_THREADS];

pthread_mutex_t aliveState_lock;


pthread_t pthread_id[NUM_CHILD_THREADS];

mqd_t get_queue_handle(TASK_IDENTIFIER_T taskid);

pthread_barrier_t tasks_barrier;


extern const char* const task_identifier_string[NUM_CHILD_THREADS+1];

/**
 * @brief Get the Task Identfier String
 * 
 * @param taskid 
 * @return const char* 
 */
static inline const char* getTaskIdentfierString(TASK_IDENTIFIER_T taskid)
{
    return task_identifier_string[taskid];
}


/**
 * @brief Registers a timer, addigns the handler and starts it
 * 
 * @param timer_id 
 * @param usec 
 * @param oneshot 
 * @param timer_handler 
 * @param handlerArgs 
 * @return int 
 */
int register_and_start_timer(timer_t *timer_id, uint32_t usec, uint8_t oneshot, void (*timer_handler)(union sigval), void *handlerArgs);


#endif/**
 * @brief 
 * 
 * @file error_data.h
 * @author Gunj Manseta
 * @date 2018-03-09
 */

#ifndef ERROR_DATA_H
#define ERROR_DATA_H

#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <stdio.h>


typedef enum{

    ERR     = -1,
    SUCCESS = 0,
}RETURN_T;

//syscall(SYS_gettid) [TID:%ld] ",getpid()

//#define LOG_STDOUT(format, ...) printf("[PID:%d]",getpid()); printf(format, ##__VA_ARGS__)
#define LOG_STDOUT(format, ...)     do{printf("[PID:%d][TID:%ld]",getpid(),syscall(SYS_gettid)); printf(format, ##__VA_ARGS__); fflush(stdout);}while(0)

#define ERROR   "[ERROR] "
#define INFO    "[INFO] "
#define SIGNAL  "[SIGNAL] "
#define WARNING "[WARNING] "


#endif/*
 * Copyright 2014 Luis Pabon, Jr.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Programming by Contract is a programming methodology
 * which binds the caller and the function called to a
 * contract. The contract is represented using Hoare Triple:
 *      {P} C {Q}
 * where {P} is the precondition before executing command C,
 * and {Q} is the postcondition.
 *
 * See also:
 * http://en.wikipedia.org/wiki/Design_by_contract
 * http://en.wikipedia.org/wiki/Hoare_logic
 * http://dlang.org/dbc.html
 */
#ifndef CMOCKA_PBC_H_
#define CMOCKA_PBC_H_

#if defined(UNIT_TESTING) || defined (DEBUG)

#include <assert.h>

/*
 * Checks caller responsibility against contract
 */
#define REQUIRE(cond) assert(cond)

/*
 * Checks function reponsability against contract.
 */
#define ENSURE(cond) assert(cond)

/*
 * While REQUIRE and ENSURE apply to functions, INVARIANT
 * applies to classes/structs.  It ensures that intances
 * of the class/struct are consistent. In other words,
 * that the instance has not been corrupted.
 */
#define INVARIANT(invariant_fnc) do{ (invariant_fnc) } while (0);

#else
#define REQUIRE(cond) do { } while (0);
#define ENSURE(cond) do { } while (0);
#define INVARIANT(invariant_fnc) do{ } while (0);

#endif /* defined(UNIT_TESTING) || defined (DEBUG) */
#endif /* CMOCKA_PBC_H_ */

/*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef CMOCKA_H_
#define CMOCKA_H_

#ifdef _WIN32
# ifdef _MSC_VER

#define __func__ __FUNCTION__

# ifndef inline
#define inline __inline
# endif /* inline */

#  if _MSC_VER < 1500
#   ifdef __cplusplus
extern "C" {
#   endif   /* __cplusplus */
int __stdcall IsDebuggerPresent();
#   ifdef __cplusplus
} /* extern "C" */
#   endif   /* __cplusplus */
#  endif  /* _MSC_VER < 1500 */
# endif /* _MSC_VER */
#endif  /* _WIN32 */

/**
 * @defgroup cmocka The CMocka API
 *
 * These headers or their equivalents should be included prior to including
 * this header file.
 * @code
 * #include <stdarg.h>
 * #include <stddef.h>
 * #include <setjmp.h>
 * @endcode
 *
 * This allows test applications to use custom definitions of C standard
 * library functions and types.
 *
 * @{
 */

/* If __WORDSIZE is not set, try to figure it out and default to 32 bit. */
#ifndef __WORDSIZE
# if defined(__x86_64__) && !defined(__ILP32__)
#  define __WORDSIZE 64
# else
#  define __WORDSIZE 32
# endif
#endif

#ifdef DOXYGEN
/**
 * Largest integral type.  This type should be large enough to hold any
 * pointer or integer supported by the compiler.
 */
typedef uintmax_t LargestIntegralType;
#else /* DOXGEN */
#ifndef LargestIntegralType
# if __WORDSIZE == 64
#  define LargestIntegralType unsigned long int
# else
#  define LargestIntegralType unsigned long long int
# endif
#endif /* LargestIntegralType */
#endif /* DOXYGEN */

/* Printf format used to display LargestIntegralType as a hexidecimal. */
#ifndef LargestIntegralTypePrintfFormat
# ifdef _WIN32
#  define LargestIntegralTypePrintfFormat "0x%I64x"
# else
#  if __WORDSIZE == 64
#   define LargestIntegralTypePrintfFormat "%#lx"
#  else
#   define LargestIntegralTypePrintfFormat "%#llx"
#  endif
# endif /* _WIN32 */
#endif /* LargestIntegralTypePrintfFormat */

/* Printf format used to display LargestIntegralType as a decimal. */
#ifndef LargestIntegralTypePrintfFormatDecimal
# ifdef _WIN32
#  define LargestIntegralTypePrintfFormatDecimal "%I64u"
# else
#  if __WORDSIZE == 64
#   define LargestIntegralTypePrintfFormatDecimal "%lu"
#  else
#   define LargestIntegralTypePrintfFormatDecimal "%llu"
#  endif
# endif /* _WIN32 */
#endif /* LargestIntegralTypePrintfFormat */

/* Perform an unsigned cast to LargestIntegralType. */
#define cast_to_largest_integral_type(value) \
    ((LargestIntegralType)(value))

/* Smallest integral type capable of holding a pointer. */
#if !defined(_UINTPTR_T) && !defined(_UINTPTR_T_DEFINED)
# if defined(_WIN32)
    /* WIN32 is an ILP32 platform */
    typedef unsigned int uintptr_t;
# elif defined(_WIN64)
    typedef unsigned long int uintptr_t
# else /* _WIN32 */

/* ILP32 and LP64 platforms */
#  ifdef __WORDSIZE /* glibc */
#   if __WORDSIZE == 64
      typedef unsigned long int uintptr_t;
#   else
      typedef unsigned int uintptr_t;
#   endif /* __WORDSIZE == 64 */
#  else /* __WORDSIZE */
#   if defined(_LP64) || defined(_I32LPx)
      typedef unsigned long int uintptr_t;
#   else
      typedef unsigned int uintptr_t;
#   endif
#  endif /* __WORDSIZE */
# endif /* _WIN32 */

# define _UINTPTR_T
# define _UINTPTR_T_DEFINED
#endif /* !defined(_UINTPTR_T) || !defined(_UINTPTR_T_DEFINED) */

/* Perform an unsigned cast to uintptr_t. */
#define cast_to_pointer_integral_type(value) \
    ((uintptr_t)((size_t)(value)))

/* Perform a cast of a pointer to LargestIntegralType */
#define cast_ptr_to_largest_integral_type(value) \
cast_to_largest_integral_type(cast_to_pointer_integral_type(value))

/* GCC have printf type attribute check.  */
#ifdef __GNUC__
#define CMOCKA_PRINTF_ATTRIBUTE(a,b) \
    __attribute__ ((__format__ (__printf__, a, b)))
#else
#define CMOCKA_PRINTF_ATTRIBUTE(a,b)
#endif /* __GNUC__ */

#if defined(__GNUC__)
#define CMOCKA_DEPRECATED __attribute__ ((deprecated))
#elif defined(_MSC_VER)
#define CMOCKA_DEPRECATED __declspec(deprecated)
#else
#define CMOCKA_DEPRECATED
#endif

#define WILL_RETURN_ALWAYS -1
#define WILL_RETURN_ONCE -2

/**
 * @defgroup cmocka_mock Mock Objects
 * @ingroup cmocka
 *
 * Mock objects mock objects are simulated objects that mimic the behavior of
 * real objects. Instead of calling the real objects, the tested object calls a
 * mock object that merely asserts that the correct methods were called, with
 * the expected parameters, in the correct order.
 *
 * <ul>
 * <li><strong>will_return(function, value)</strong> - The will_return() macro
 * pushes a value onto a stack of mock values. This macro is intended to be
 * used by the unit test itself, while programming the behaviour of the mocked
 * object.</li>
 *
 * <li><strong>mock()</strong> - the mock macro pops a value from a stack of
 * test values. The user of the mock() macro is the mocked object that uses it
 * to learn how it should behave.</li>
 * </ul>
 *
 * Because the will_return() and mock() are intended to be used in pairs, the
 * cmocka library would fail the test if there are more values pushed onto the
 * stack using will_return() than consumed with mock() and vice-versa.
 *
 * The following unit test stub illustrates how would a unit test instruct the
 * mock object to return a particular value:
 *
 * @code
 * will_return(chef_cook, "hotdog");
 * will_return(chef_cook, 0);
 * @endcode
 *
 * Now the mock object can check if the parameter it received is the parameter
 * which is expected by the test driver. This can be done the following way:
 *
 * @code
 * int chef_cook(const char *order, char **dish_out)
 * {
 *     check_expected(order);
 * }
 * @endcode
 *
 * For a complete example please at a look
 * <a href="http://git.cryptomilk.org/projects/cmocka.git/tree/example/chef_wrap/waiter_test_wrap.c">here</a>.
 *
 * @{
 */

#ifdef DOXYGEN
/**
 * @brief Retrieve a return value of the current function.
 *
 * @return The value which was stored to return by this function.
 *
 * @see will_return()
 */
LargestIntegralType mock(void);
#else
#define mock() _mock(__func__, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Retrieve a typed return value of the current function.
 *
 * The value would be casted to type internally to avoid having the
 * caller to do the cast manually.
 *
 * @param[in]  #type  The expected type of the return value
 *
 * @return The value which was stored to return by this function.
 *
 * @code
 * int param;
 *
 * param = mock_type(int);
 * @endcode
 *
 * @see will_return()
 * @see mock()
 * @see mock_ptr_type()
 */
#type mock_type(#type);
#else
#define mock_type(type) ((type) mock())
#endif

#ifdef DOXYGEN
/**
 * @brief Retrieve a typed return value of the current function.
 *
 * The value would be casted to type internally to avoid having the
 * caller to do the cast manually but also casted to uintptr_t to make
 * sure the result has a valid size to be used as a pointer.
 *
 * @param[in]  #type  The expected type of the return value
 *
 * @return The value which was stored to return by this function.
 *
 * @code
 * char *param;
 *
 * param = mock_ptr_type(char *);
 * @endcode
 *
 * @see will_return()
 * @see mock()
 * @see mock_type()
 */
type mock_ptr_type(#type);
#else
#define mock_ptr_type(type) ((type) (uintptr_t) mock())
#endif


#ifdef DOXYGEN
/**
 * @brief Store a value to be returned by mock() later.
 *
 * @param[in]  #function  The function which should return the given value.
 *
 * @param[in]  value The value to be returned by mock().
 *
 * @code
 * int return_integer(void)
 * {
 *      return (int)mock();
 * }
 *
 * static void test_integer_return(void **state)
 * {
 *      will_return(return_integer, 42);
 *
 *      assert_int_equal(my_function_calling_return_integer(), 42);
 * }
 * @endcode
 *
 * @see mock()
 * @see will_return_count()
 */
void will_return(#function, LargestIntegralType value);
#else
#define will_return(function, value) \
    _will_return(#function, __FILE__, __LINE__, \
                 cast_to_largest_integral_type(value), 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Store a value to be returned by mock() later.
 *
 * @param[in]  #function  The function which should return the given value.
 *
 * @param[in]  value The value to be returned by mock().
 *
 * @param[in]  count The parameter indicates the number of times the value should
 *                   be returned by mock(). If count is set to -1, the value
 *                   will always be returned but must be returned at least once.
 *                   If count is set to -2, the value will always be returned
 *                   by mock(), but is not required to be returned.
 *
 * @see mock()
 */
void will_return_count(#function, LargestIntegralType value, int count);
#else
#define will_return_count(function, value, count) \
    _will_return(#function, __FILE__, __LINE__, \
                 cast_to_largest_integral_type(value), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Store a value that will be always returned by mock().
 *
 * @param[in]  #function  The function which should return the given value.
 *
 * @param[in]  #value The value to be returned by mock().
 *
 * This is equivalent to:
 * @code
 * will_return_count(function, value, -1);
 * @endcode
 *
 * @see will_return_count()
 * @see mock()
 */
void will_return_always(#function, LargestIntegralType value);
#else
#define will_return_always(function, value) \
    will_return_count(function, (value), WILL_RETURN_ALWAYS)
#endif

#ifdef DOXYGEN
/**
 * @brief Store a value that may be always returned by mock().
 *
 * This stores a value which will always be returned by mock() but is not
 * required to be returned by at least one call to mock(). Therefore,
 * in contrast to will_return_always() which causes a test failure if it
 * is not returned at least once, will_return_maybe() will never cause a test
 * to fail if its value is not returned.
 *
 * @param[in]  #function  The function which should return the given value.
 *
 * @param[in]  #value The value to be returned by mock().
 *
 * This is equivalent to:
 * @code
 * will_return_count(function, value, -2);
 * @endcode
 *
 * @see will_return_count()
 * @see mock()
 */
void will_return_maybe(#function, LargestIntegralType value);
#else
#define will_return_maybe(function, value) \
    will_return_count(function, (value), WILL_RETURN_ONCE)
#endif
/** @} */

/**
 * @defgroup cmocka_param Checking Parameters
 * @ingroup cmocka
 *
 * Functionality to store expected values for mock function parameters.
 *
 * In addition to storing the return values of mock functions, cmocka provides
 * functionality to store expected values for mock function parameters using
 * the expect_*() functions provided. A mock function parameter can then be
 * validated using the check_expected() macro.
 *
 * Successive calls to expect_*() macros for a parameter queues values to check
 * the specified parameter. check_expected() checks a function parameter
 * against the next value queued using expect_*(), if the parameter check fails
 * a test failure is signalled. In addition if check_expected() is called and
 * no more parameter values are queued a test failure occurs.
 *
 * The following test stub illustrates how to do this. First is the the function
 * we call in the test driver:
 *
 * @code
 * static void test_driver(void **state)
 * {
 *     expect_string(chef_cook, order, "hotdog");
 * }
 * @endcode
 *
 * Now the chef_cook function can check if the parameter we got passed is the
 * parameter which is expected by the test driver. This can be done the
 * following way:
 *
 * @code
 * int chef_cook(const char *order, char **dish_out)
 * {
 *     check_expected(order);
 * }
 * @endcode
 *
 * For a complete example please at a look at
 * <a href="http://git.cryptomilk.org/projects/cmocka.git/tree/example/chef_wrap/waiter_test_wrap.c">here</a>
 *
 * @{
 */

/*
 * Add a custom parameter checking function.  If the event parameter is NULL
 * the event structure is allocated internally by this function.  If event
 * parameter is provided it must be allocated on the heap and doesn't need to
 * be deallocated by the caller.
 */
#ifdef DOXYGEN
/**
 * @brief Add a custom parameter checking function.
 *
 * If the event parameter is NULL the event structure is allocated internally
 * by this function. If the parameter is provided it must be allocated on the
 * heap and doesn't need to be deallocated by the caller.
 *
 * @param[in]  #function  The function to add a custom parameter checking
 *                        function for.
 *
 * @param[in]  #parameter The parameters passed to the function.
 *
 * @param[in]  #check_function  The check function to call.
 *
 * @param[in]  check_data       The data to pass to the check function.
 */
void expect_check(#function, #parameter, #check_function, const void *check_data);
#else
#define expect_check(function, parameter, check_function, check_data) \
    _expect_check(#function, #parameter, __FILE__, __LINE__, check_function, \
                  cast_to_largest_integral_type(check_data), NULL, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is part of the provided
 *        array.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value_array[] The array to check for the value.
 *
 * @see check_expected().
 */
void expect_in_set(#function, #parameter, LargestIntegralType value_array[]);
#else
#define expect_in_set(function, parameter, value_array) \
    expect_in_set_count(function, parameter, value_array, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is part of the provided
 *        array.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value_array[] The array to check for the value.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_in_set_count(#function, #parameter, LargestIntegralType value_array[], size_t count);
#else
#define expect_in_set_count(function, parameter, value_array, count) \
    _expect_in_set(#function, #parameter, __FILE__, __LINE__, value_array, \
                   sizeof(value_array) / sizeof((value_array)[0]), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is not part of the
 *        provided array.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value_array[] The array to check for the value.
 *
 * @see check_expected().
 */
void expect_not_in_set(#function, #parameter, LargestIntegralType value_array[]);
#else
#define expect_not_in_set(function, parameter, value_array) \
    expect_not_in_set_count(function, parameter, value_array, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is not part of the
 *        provided array.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value_array[] The array to check for the value.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_in_set_count(#function, #parameter, LargestIntegralType value_array[], size_t count);
#else
#define expect_not_in_set_count(function, parameter, value_array, count) \
    _expect_not_in_set( \
        #function, #parameter, __FILE__, __LINE__, value_array, \
        sizeof(value_array) / sizeof((value_array)[0]), count)
#endif


#ifdef DOXYGEN
/**
 * @brief Add an event to check a parameter is inside a numerical range.
 * The check would succeed if minimum <= value <= maximum.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  minimum  The lower boundary of the interval to check against.
 *
 * @param[in]  maximum  The upper boundary of the interval to check against.
 *
 * @see check_expected().
 */
void expect_in_range(#function, #parameter, LargestIntegralType minimum, LargestIntegralType maximum);
#else
#define expect_in_range(function, parameter, minimum, maximum) \
    expect_in_range_count(function, parameter, minimum, maximum, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check a parameter is inside a
 * numerical range. The check would succeed if minimum <= value <= maximum.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  minimum  The lower boundary of the interval to check against.
 *
 * @param[in]  maximum  The upper boundary of the interval to check against.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_in_range_count(#function, #parameter, LargestIntegralType minimum, LargestIntegralType maximum, size_t count);
#else
#define expect_in_range_count(function, parameter, minimum, maximum, count) \
    _expect_in_range(#function, #parameter, __FILE__, __LINE__, minimum, \
                     maximum, count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check a parameter is outside a numerical range.
 * The check would succeed if minimum > value > maximum.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  minimum  The lower boundary of the interval to check against.
 *
 * @param[in]  maximum  The upper boundary of the interval to check against.
 *
 * @see check_expected().
 */
void expect_not_in_range(#function, #parameter, LargestIntegralType minimum, LargestIntegralType maximum);
#else
#define expect_not_in_range(function, parameter, minimum, maximum) \
    expect_not_in_range_count(function, parameter, minimum, maximum, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check a parameter is outside a
 * numerical range. The check would succeed if minimum > value > maximum.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  minimum  The lower boundary of the interval to check against.
 *
 * @param[in]  maximum  The upper boundary of the interval to check against.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_in_range_count(#function, #parameter, LargestIntegralType minimum, LargestIntegralType maximum, size_t count);
#else
#define expect_not_in_range_count(function, parameter, minimum, maximum, \
                                  count) \
    _expect_not_in_range(#function, #parameter, __FILE__, __LINE__, \
                         minimum, maximum, count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if a parameter is the given value.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value  The value to check.
 *
 * @see check_expected().
 */
void expect_value(#function, #parameter, LargestIntegralType value);
#else
#define expect_value(function, parameter, value) \
    expect_value_count(function, parameter, value, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if a parameter is the given value.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value  The value to check.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_value_count(#function, #parameter, LargestIntegralType value, size_t count);
#else
#define expect_value_count(function, parameter, value, count) \
    _expect_value(#function, #parameter, __FILE__, __LINE__, \
                  cast_to_largest_integral_type(value), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if a parameter isn't the given value.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value  The value to check.
 *
 * @see check_expected().
 */
void expect_not_value(#function, #parameter, LargestIntegralType value);
#else
#define expect_not_value(function, parameter, value) \
    expect_not_value_count(function, parameter, value, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if a parameter isn't the given value.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value  The value to check.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_value_count(#function, #parameter, LargestIntegralType value, size_t count);
#else
#define expect_not_value_count(function, parameter, value, count) \
    _expect_not_value(#function, #parameter, __FILE__, __LINE__, \
                      cast_to_largest_integral_type(value), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is equal to the
 *        provided string.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  string   The string value to compare.
 *
 * @see check_expected().
 */
void expect_string(#function, #parameter, const char *string);
#else
#define expect_string(function, parameter, string) \
    expect_string_count(function, parameter, string, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is equal to the
 *        provided string.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  string   The string value to compare.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_string_count(#function, #parameter, const char *string, size_t count);
#else
#define expect_string_count(function, parameter, string, count) \
    _expect_string(#function, #parameter, __FILE__, __LINE__, \
                   (const char*)(string), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value isn't equal to the
 *        provided string.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  string   The string value to compare.
 *
 * @see check_expected().
 */
void expect_not_string(#function, #parameter, const char *string);
#else
#define expect_not_string(function, parameter, string) \
    expect_not_string_count(function, parameter, string, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value isn't equal to the
 *        provided string.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  string   The string value to compare.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_string_count(#function, #parameter, const char *string, size_t count);
#else
#define expect_not_string_count(function, parameter, string, count) \
    _expect_not_string(#function, #parameter, __FILE__, __LINE__, \
                       (const char*)(string), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter does match an area of memory.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  memory  The memory to compare.
 *
 * @param[in]  size  The size of the memory to compare.
 *
 * @see check_expected().
 */
void expect_memory(#function, #parameter, void *memory, size_t size);
#else
#define expect_memory(function, parameter, memory, size) \
    expect_memory_count(function, parameter, memory, size, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if the parameter does match an area
 *        of memory.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  memory  The memory to compare.
 *
 * @param[in]  size  The size of the memory to compare.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_memory_count(#function, #parameter, void *memory, size_t size, size_t count);
#else
#define expect_memory_count(function, parameter, memory, size, count) \
    _expect_memory(#function, #parameter, __FILE__, __LINE__, \
                   (const void*)(memory), size, count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter doesn't match an area of
 *        memory.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  memory  The memory to compare.
 *
 * @param[in]  size  The size of the memory to compare.
 *
 * @see check_expected().
 */
void expect_not_memory(#function, #parameter, void *memory, size_t size);
#else
#define expect_not_memory(function, parameter, memory, size) \
    expect_not_memory_count(function, parameter, memory, size, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if the parameter doesn't match an
 *        area of memory.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  memory  The memory to compare.
 *
 * @param[in]  size  The size of the memory to compare.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_memory_count(#function, #parameter, void *memory, size_t size, size_t count);
#else
#define expect_not_memory_count(function, parameter, memory, size, count) \
    _expect_not_memory(#function, #parameter, __FILE__, __LINE__, \
                       (const void*)(memory), size, count)
#endif


#ifdef DOXYGEN
/**
 * @brief Add an event to check if a parameter (of any value) has been passed.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @see check_expected().
 */
void expect_any(#function, #parameter);
#else
#define expect_any(function, parameter) \
    expect_any_count(function, parameter, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if a parameter (of any value) has
 *        been passed.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_any_count(#function, #parameter, size_t count);
#else
#define expect_any_count(function, parameter, count) \
    _expect_any(#function, #parameter, __FILE__, __LINE__, count)
#endif

#ifdef DOXYGEN
/**
 * @brief Determine whether a function parameter is correct.
 *
 * This ensures the next value queued by one of the expect_*() macros matches
 * the specified variable.
 *
 * This function needs to be called in the mock object.
 *
 * @param[in]  #parameter  The parameter to check.
 */
void check_expected(#parameter);
#else
#define check_expected(parameter) \
    _check_expected(__func__, #parameter, __FILE__, __LINE__, \
                    cast_to_largest_integral_type(parameter))
#endif

#ifdef DOXYGEN
/**
 * @brief Determine whether a function parameter is correct.
 *
 * This ensures the next value queued by one of the expect_*() macros matches
 * the specified variable.
 *
 * This function needs to be called in the mock object.
 *
 * @param[in]  #parameter  The pointer to check.
 */
void check_expected_ptr(#parameter);
#else
#define check_expected_ptr(parameter) \
    _check_expected(__func__, #parameter, __FILE__, __LINE__, \
                    cast_ptr_to_largest_integral_type(parameter))
#endif

/** @} */

/**
 * @defgroup cmocka_asserts Assert Macros
 * @ingroup cmocka
 *
 * This is a set of useful assert macros like the standard C libary's
 * assert(3) macro.
 *
 * On an assertion failure a cmocka assert macro will write the failure to the
 * standard error stream and signal a test failure. Due to limitations of the C
 * language the general C standard library assert() and cmocka's assert_true()
 * and assert_false() macros can only display the expression that caused the
 * assert failure. cmocka's type specific assert macros, assert_{type}_equal()
 * and assert_{type}_not_equal(), display the data that caused the assertion
 * failure which increases data visibility aiding debugging of failing test
 * cases.
 *
 * @{
 */

#ifdef DOXYGEN
/**
 * @brief Assert that the given expression is true.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if expression is false (i.e., compares equal to
 * zero).
 *
 * @param[in]  expression  The expression to evaluate.
 *
 * @see assert_int_equal()
 * @see assert_string_equal()
 */
void assert_true(scalar expression);
#else
#define assert_true(c) _assert_true(cast_to_largest_integral_type(c), #c, \
                                    __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the given expression is false.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if expression is true.
 *
 * @param[in]  expression  The expression to evaluate.
 *
 * @see assert_int_equal()
 * @see assert_string_equal()
 */
void assert_false(scalar expression);
#else
#define assert_false(c) _assert_true(!(cast_to_largest_integral_type(c)), #c, \
                                     __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the return_code is greater than or equal to 0.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the return code is smaller than 0. If the function
 * you check sets an errno if it fails you can pass it to the function and
 * it will be printed as part of the error message.
 *
 * @param[in]  rc       The return code to evaluate.
 *
 * @param[in]  error    Pass errno here or 0.
 */
void assert_return_code(int rc, int error);
#else
#define assert_return_code(rc, error) \
    _assert_return_code(cast_to_largest_integral_type(rc), \
                        sizeof(rc), \
                        cast_to_largest_integral_type(error), \
                        #rc, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the given pointer is non-NULL.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the pointer is non-NULL.
 *
 * @param[in]  pointer  The pointer to evaluate.
 *
 * @see assert_null()
 */
void assert_non_null(void *pointer);
#else
#define assert_non_null(c) _assert_true(cast_ptr_to_largest_integral_type(c), #c, \
                                        __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the given pointer is NULL.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the pointer is non-NULL.
 *
 * @param[in]  pointer  The pointer to evaluate.
 *
 * @see assert_non_null()
 */
void assert_null(void *pointer);
#else
#define assert_null(c) _assert_true(!(cast_ptr_to_largest_integral_type(c)), #c, \
__FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given pointers are equal.
 *
 * The function prints an error message and terminates the test by calling
 * fail() if the pointers are not equal.
 *
 * @param[in]  a        The first pointer to compare.
 *
 * @param[in]  b        The pointer to compare against the first one.
 */
void assert_ptr_equal(void *a, void *b);
#else
#define assert_ptr_equal(a, b) \
    _assert_int_equal(cast_ptr_to_largest_integral_type(a), \
                      cast_ptr_to_largest_integral_type(b), \
                      __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given pointers are not equal.
 *
 * The function prints an error message and terminates the test by calling
 * fail() if the pointers are equal.
 *
 * @param[in]  a        The first pointer to compare.
 *
 * @param[in]  b        The pointer to compare against the first one.
 */
void assert_ptr_not_equal(void *a, void *b);
#else
#define assert_ptr_not_equal(a, b) \
    _assert_int_not_equal(cast_ptr_to_largest_integral_type(a), \
                          cast_ptr_to_largest_integral_type(b), \
                          __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given integers are equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the integers are not equal.
 *
 * @param[in]  a  The first integer to compare.
 *
 * @param[in]  b  The integer to compare against the first one.
 */
void assert_int_equal(int a, int b);
#else
#define assert_int_equal(a, b) \
    _assert_int_equal(cast_to_largest_integral_type(a), \
                      cast_to_largest_integral_type(b), \
                      __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given integers are not equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the integers are equal.
 *
 * @param[in]  a  The first integer to compare.
 *
 * @param[in]  b  The integer to compare against the first one.
 *
 * @see assert_int_equal()
 */
void assert_int_not_equal(int a, int b);
#else
#define assert_int_not_equal(a, b) \
    _assert_int_not_equal(cast_to_largest_integral_type(a), \
                          cast_to_largest_integral_type(b), \
                          __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given strings are equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the strings are not equal.
 *
 * @param[in]  a  The string to check.
 *
 * @param[in]  b  The other string to compare.
 */
void assert_string_equal(const char *a, const char *b);
#else
#define assert_string_equal(a, b) \
    _assert_string_equal((const char*)(a), (const char*)(b), __FILE__, \
                         __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given strings are not equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the strings are equal.
 *
 * @param[in]  a  The string to check.
 *
 * @param[in]  b  The other string to compare.
 */
void assert_string_not_equal(const char *a, const char *b);
#else
#define assert_string_not_equal(a, b) \
    _assert_string_not_equal((const char*)(a), (const char*)(b), __FILE__, \
                             __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given areas of memory are equal, otherwise fail.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the memory is not equal.
 *
 * @param[in]  a  The first memory area to compare
 *                (interpreted as unsigned char).
 *
 * @param[in]  b  The second memory area to compare
 *                (interpreted as unsigned char).
 *
 * @param[in]  size  The first n bytes of the memory areas to compare.
 */
void assert_memory_equal(const void *a, const void *b, size_t size);
#else
#define assert_memory_equal(a, b, size) \
    _assert_memory_equal((const void*)(a), (const void*)(b), size, __FILE__, \
                         __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given areas of memory are not equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the memory is equal.
 *
 * @param[in]  a  The first memory area to compare
 *                (interpreted as unsigned char).
 *
 * @param[in]  b  The second memory area to compare
 *                (interpreted as unsigned char).
 *
 * @param[in]  size  The first n bytes of the memory areas to compare.
 */
void assert_memory_not_equal(const void *a, const void *b, size_t size);
#else
#define assert_memory_not_equal(a, b, size) \
    _assert_memory_not_equal((const void*)(a), (const void*)(b), size, \
                             __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the specified value is not smaller than the minimum
 * and and not greater than the maximum.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if value is not in range.
 *
 * @param[in]  value  The value to check.
 *
 * @param[in]  minimum  The minimum value allowed.
 *
 * @param[in]  maximum  The maximum value allowed.
 */
void assert_in_range(LargestIntegralType value, LargestIntegralType minimum, LargestIntegralType maximum);
#else
#define assert_in_range(value, minimum, maximum) \
    _assert_in_range( \
        cast_to_largest_integral_type(value), \
        cast_to_largest_integral_type(minimum), \
        cast_to_largest_integral_type(maximum), __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the specified value is smaller than the minimum or
 * greater than the maximum.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if value is in range.
 *
 * @param[in]  value  The value to check.
 *
 * @param[in]  minimum  The minimum value to compare.
 *
 * @param[in]  maximum  The maximum value to compare.
 */
void assert_not_in_range(LargestIntegralType value, LargestIntegralType minimum, LargestIntegralType maximum);
#else
#define assert_not_in_range(value, minimum, maximum) \
    _assert_not_in_range( \
        cast_to_largest_integral_type(value), \
        cast_to_largest_integral_type(minimum), \
        cast_to_largest_integral_type(maximum), __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the specified value is within a set.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if value is not within a set.
 *
 * @param[in]  value  The value to look up
 *
 * @param[in]  values[]  The array to check for the value.
 *
 * @param[in]  count  The size of the values array.
 */
void assert_in_set(LargestIntegralType value, LargestIntegralType values[], size_t count);
#else
#define assert_in_set(value, values, number_of_values) \
    _assert_in_set(value, values, number_of_values, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the specified value is not within a set.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if value is within a set.
 *
 * @param[in]  value  The value to look up
 *
 * @param[in]  values[]  The array to check for the value.
 *
 * @param[in]  count  The size of the values array.
 */
void assert_not_in_set(LargestIntegralType value, LargestIntegralType values[], size_t count);
#else
#define assert_not_in_set(value, values, number_of_values) \
    _assert_not_in_set(value, values, number_of_values, __FILE__, __LINE__)
#endif

/** @} */

/**
 * @defgroup cmocka_call_order Call Ordering
 * @ingroup cmocka
 *
 * It is often beneficial to  make sure that functions are called in an
 * order. This is independent of mock returns and parameter checking as both
 * of the aforementioned do not check the order in which they are called from
 * different functions.
 *
 * <ul>
 * <li><strong>expect_function_call(function)</strong> - The
 * expect_function_call() macro pushes an expectation onto the stack of
 * expected calls.</li>
 *
 * <li><strong>function_called()</strong> - pops a value from the stack of
 * expected calls. function_called() is invoked within the mock object
 * that uses it.
 * </ul>
 *
 * expect_function_call() and function_called() are intended to be used in
 * pairs. Cmocka will fail a test if there are more or less expected calls
 * created (e.g. expect_function_call()) than consumed with function_called().
 * There are provisions such as ignore_function_calls() which allow this
 * restriction to be circumvented in tests where mock calls for the code under
 * test are not the focus of the test.
 *
 * The following example illustrates how a unit test instructs cmocka
 * to expect a function_called() from a particular mock,
 * <strong>chef_sing()</strong>:
 *
 * @code
 * void chef_sing(void);
 *
 * void code_under_test()
 * {
 *   chef_sing();
 * }
 *
 * void some_test(void **state)
 * {
 *     expect_function_call(chef_sing);
 *     code_under_test();
 * }
 * @endcode
 *
 * The implementation of the mock then must check whether it was meant to
 * be called by invoking <strong>function_called()</strong>:
 *
 * @code
 * void chef_sing()
 * {
 *     function_called();
 * }
 * @endcode
 *
 * @{
 */

#ifdef DOXYGEN
/**
 * @brief Check that current mocked function is being called in the expected
 *        order
 *
 * @see expect_function_call()
 */
void function_called(void);
#else
#define function_called() _function_called(__func__, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Store expected call(s) to a mock to be checked by function_called()
 *        later.
 *
 * @param[in]  #function  The function which should should be called
 *
 * @param[in]  times number of times this mock must be called
 *
 * @see function_called()
 */
void expect_function_calls(#function, const int times);
#else
#define expect_function_calls(function, times) \
    _expect_function_call(#function, __FILE__, __LINE__, times)
#endif

#ifdef DOXYGEN
/**
 * @brief Store expected single call to a mock to be checked by
 *        function_called() later.
 *
 * @param[in]  #function  The function which should should be called
 *
 * @see function_called()
 */
void expect_function_call(#function);
#else
#define expect_function_call(function) \
    _expect_function_call(#function, __FILE__, __LINE__, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Expects function_called() from given mock at least once
 *
 * @param[in]  #function  The function which should should be called
 *
 * @see function_called()
 */
void expect_function_call_any(#function);
#else
#define expect_function_call_any(function) \
    _expect_function_call(#function, __FILE__, __LINE__, -1)
#endif

#ifdef DOXYGEN
/**
 * @brief Ignores function_called() invocations from given mock function.
 *
 * @param[in]  #function  The function which should should be called
 *
 * @see function_called()
 */
void ignore_function_calls(#function);
#else
#define ignore_function_calls(function) \
    _expect_function_call(#function, __FILE__, __LINE__, -2)
#endif

/** @} */

/**
 * @defgroup cmocka_exec Running Tests
 * @ingroup cmocka
 *
 * This is the way tests are executed with CMocka.
 *
 * The following example illustrates this macro's use with the unit_test macro.
 *
 * @code
 * void Test0(void **state);
 * void Test1(void **state);
 *
 * int main(void)
 * {
 *     const struct CMUnitTest tests[] = {
 *         cmocka_unit_test(Test0),
 *         cmocka_unit_test(Test1),
 *     };
 *
 *     return cmocka_run_group_tests(tests, NULL, NULL);
 * }
 * @endcode
 *
 * @{
 */

#ifdef DOXYGEN
/**
 * @brief Forces the test to fail immediately and quit.
 */
void fail(void);
#else
#define fail() _fail(__FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Forces the test to not be executed, but marked as skipped
 */
void skip(void);
#else
#define skip() _skip(__FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Forces the test to fail immediately and quit, printing the reason.
 *
 * @code
 * fail_msg("This is some error message for test");
 * @endcode
 *
 * or
 *
 * @code
 * char *error_msg = "This is some error message for test";
 * fail_msg("%s", error_msg);
 * @endcode
 */
void fail_msg(const char *msg, ...);
#else
#define fail_msg(msg, ...) do { \
    print_error("ERROR: " msg "\n", ##__VA_ARGS__); \
    fail(); \
} while (0)
#endif

#ifdef DOXYGEN
/**
 * @brief Generic method to run a single test.
 *
 * @deprecated This function was deprecated in favor of cmocka_run_group_tests
 *
 * @param[in]  #function The function to test.
 *
 * @return 0 on success, 1 if an error occured.
 *
 * @code
 * // A test case that does nothing and succeeds.
 * void null_test_success(void **state) {
 * }
 *
 * int main(void) {
 *      return run_test(null_test_success);
 * }
 * @endcode
 */
int run_test(#function);
#else
#define run_test(f) _run_test(#f, f, NULL, UNIT_TEST_FUNCTION_TYPE_TEST, NULL)
#endif

static inline void _unit_test_dummy(void **state) {
    (void)state;
}

/** Initializes a UnitTest structure.
 *
 * @deprecated This function was deprecated in favor of cmocka_unit_test
 */
#define unit_test(f) { #f, f, UNIT_TEST_FUNCTION_TYPE_TEST }

#define _unit_test_setup(test, setup) \
    { #test "_" #setup, setup, UNIT_TEST_FUNCTION_TYPE_SETUP }

/** Initializes a UnitTest structure with a setup function.
 *
 * @deprecated This function was deprecated in favor of cmocka_unit_test_setup
 */
#define unit_test_setup(test, setup) \
    _unit_test_setup(test, setup), \
    unit_test(test), \
    _unit_test_teardown(test, _unit_test_dummy)

#define _unit_test_teardown(test, teardown) \
    { #test "_" #teardown, teardown, UNIT_TEST_FUNCTION_TYPE_TEARDOWN }

/** Initializes a UnitTest structure with a teardown function.
 *
 * @deprecated This function was deprecated in favor of cmocka_unit_test_teardown
 */
#define unit_test_teardown(test, teardown) \
    _unit_test_setup(test, _unit_test_dummy), \
    unit_test(test), \
    _unit_test_teardown(test, teardown)

/** Initializes a UnitTest structure for a group setup function.
 *
 * @deprecated This function was deprecated in favor of cmocka_run_group_tests
 */
#define group_test_setup(setup) \
    { "group_" #setup, setup, UNIT_TEST_FUNCTION_TYPE_GROUP_SETUP }

/** Initializes a UnitTest structure for a group teardown function.
 *
 * @deprecated This function was deprecated in favor of cmocka_run_group_tests
 */
#define group_test_teardown(teardown) \
    { "group_" #teardown, teardown, UNIT_TEST_FUNCTION_TYPE_GROUP_TEARDOWN }

/**
 * Initialize an array of UnitTest structures with a setup function for a test
 * and a teardown function.  Either setup or teardown can be NULL.
 *
 * @deprecated This function was deprecated in favor of
 * cmocka_unit_test_setup_teardown
 */
#define unit_test_setup_teardown(test, setup, teardown) \
    _unit_test_setup(test, setup), \
    unit_test(test), \
    _unit_test_teardown(test, teardown)


/** Initializes a CMUnitTest structure. */
#define cmocka_unit_test(f) { #f, f, NULL, NULL, NULL }

/** Initializes a CMUnitTest structure with a setup function. */
#define cmocka_unit_test_setup(f, setup) { #f, f, setup, NULL, NULL }

/** Initializes a CMUnitTest structure with a teardown function. */
#define cmocka_unit_test_teardown(f, teardown) { #f, f, NULL, teardown, NULL }

/**
 * Initialize an array of CMUnitTest structures with a setup function for a test
 * and a teardown function. Either setup or teardown can be NULL.
 */
#define cmocka_unit_test_setup_teardown(f, setup, teardown) { #f, f, setup, teardown, NULL }

/**
 * Initialize a CMUnitTest structure with given initial state. It will be passed
 * to test function as an argument later. It can be used when test state does
 * not need special initialization or was initialized already.
 * @note If the group setup function initialized the state already, it won't be
 * overridden by the initial state defined here.
 */
#define cmocka_unit_test_prestate(f, state) { #f, f, NULL, NULL, state }

/**
 * Initialize a CMUnitTest structure with given initial state, setup and
 * teardown function. Any of these values can be NULL. Initial state is passed
 * later to setup function, or directly to test if none was given.
 * @note If the group setup function initialized the state already, it won't be
 * overridden by the initial state defined here.
 */
#define cmocka_unit_test_prestate_setup_teardown(f, setup, teardown, state) { #f, f, setup, teardown, state }

#define run_tests(tests) _run_tests(tests, sizeof(tests) / sizeof(tests)[0])
#define run_group_tests(tests) _run_group_tests(tests, sizeof(tests) / sizeof(tests)[0])

#ifdef DOXYGEN
/**
 * @brief Run tests specified by an array of CMUnitTest structures.
 *
 * @param[in]  group_tests[]  The array of unit tests to execute.
 *
 * @param[in]  group_setup    The setup function which should be called before
 *                            all unit tests are executed.
 *
 * @param[in]  group_teardown The teardown function to be called after all
 *                            tests have finished.
 *
 * @return 0 on success, or the number of failed tests.
 *
 * @code
 * static int setup(void **state) {
 *      int *answer = malloc(sizeof(int));
 *      if (*answer == NULL) {
 *          return -1;
 *      }
 *      *answer = 42;
 *
 *      *state = answer;
 *
 *      return 0;
 * }
 *
 * static int teardown(void **state) {
 *      free(*state);
 *
 *      return 0;
 * }
 *
 * static void null_test_success(void **state) {
 *     (void) state;
 * }
 *
 * static void int_test_success(void **state) {
 *      int *answer = *state;
 *      assert_int_equal(*answer, 42);
 * }
 *
 * int main(void) {
 *     const struct CMUnitTest tests[] = {
 *         cmocka_unit_test(null_test_success),
 *         cmocka_unit_test_setup_teardown(int_test_success, setup, teardown),
 *     };
 *
 *     return cmocka_run_group_tests(tests, NULL, NULL);
 * }
 * @endcode
 *
 * @see cmocka_unit_test
 * @see cmocka_unit_test_setup
 * @see cmocka_unit_test_teardown
 * @see cmocka_unit_test_setup_teardown
 */
int cmocka_run_group_tests(const struct CMUnitTest group_tests[],
                           CMFixtureFunction group_setup,
                           CMFixtureFunction group_teardown);
#else
# define cmocka_run_group_tests(group_tests, group_setup, group_teardown) \
        _cmocka_run_group_tests(#group_tests, group_tests, sizeof(group_tests) / sizeof(group_tests)[0], group_setup, group_teardown)
#endif

#ifdef DOXYGEN
/**
 * @brief Run tests specified by an array of CMUnitTest structures and specify
 *        a name.
 *
 * @param[in]  group_name     The name of the group test.
 *
 * @param[in]  group_tests[]  The array of unit tests to execute.
 *
 * @param[in]  group_setup    The setup function which should be called before
 *                            all unit tests are executed.
 *
 * @param[in]  group_teardown The teardown function to be called after all
 *                            tests have finished.
 *
 * @return 0 on success, or the number of failed tests.
 *
 * @code
 * static int setup(void **state) {
 *      int *answer = malloc(sizeof(int));
 *      if (*answer == NULL) {
 *          return -1;
 *      }
 *      *answer = 42;
 *
 *      *state = answer;
 *
 *      return 0;
 * }
 *
 * static int teardown(void **state) {
 *      free(*state);
 *
 *      return 0;
 * }
 *
 * static void null_test_success(void **state) {
 *     (void) state;
 * }
 *
 * static void int_test_success(void **state) {
 *      int *answer = *state;
 *      assert_int_equal(*answer, 42);
 * }
 *
 * int main(void) {
 *     const struct CMUnitTest tests[] = {
 *         cmocka_unit_test(null_test_success),
 *         cmocka_unit_test_setup_teardown(int_test_success, setup, teardown),
 *     };
 *
 *     return cmocka_run_group_tests_name("success_test", tests, NULL, NULL);
 * }
 * @endcode
 *
 * @see cmocka_unit_test
 * @see cmocka_unit_test_setup
 * @see cmocka_unit_test_teardown
 * @see cmocka_unit_test_setup_teardown
 */
int cmocka_run_group_tests_name(const char *group_name,
                                const struct CMUnitTest group_tests[],
                                CMFixtureFunction group_setup,
                                CMFixtureFunction group_teardown);
#else
# define cmocka_run_group_tests_name(group_name, group_tests, group_setup, group_teardown) \
        _cmocka_run_group_tests(group_name, group_tests, sizeof(group_tests) / sizeof(group_tests)[0], group_setup, group_teardown)
#endif

/** @} */

/**
 * @defgroup cmocka_alloc Dynamic Memory Allocation
 * @ingroup cmocka
 *
 * Memory leaks, buffer overflows and underflows can be checked using cmocka.
 *
 * To test for memory leaks, buffer overflows and underflows a module being
 * tested by cmocka should replace calls to malloc(), calloc() and free() to
 * test_malloc(), test_calloc() and test_free() respectively. Each time a block
 * is deallocated using test_free() it is checked for corruption, if a corrupt
 * block is found a test failure is signalled. All blocks allocated using the
 * test_*() allocation functions are tracked by the cmocka library. When a test
 * completes if any allocated blocks (memory leaks) remain they are reported
 * and a test failure is signalled.
 *
 * For simplicity cmocka currently executes all tests in one process. Therefore
 * all test cases in a test application share a single address space which
 * means memory corruption from a single test case could potentially cause the
 * test application to exit prematurely.
 *
 * @{
 */

#ifdef DOXYGEN
/**
 * @brief Test function overriding malloc.
 *
 * @param[in]  size  The bytes which should be allocated.
 *
 * @return A pointer to the allocated memory or NULL on error.
 *
 * @code
 * #ifdef UNIT_TESTING
 * extern void* _test_malloc(const size_t size, const char* file, const int line);
 *
 * #define malloc(size) _test_malloc(size, __FILE__, __LINE__)
 * #endif
 *
 * void leak_memory() {
 *     int * const temporary = (int*)malloc(sizeof(int));
 *     *temporary = 0;
 * }
 * @endcode
 *
 * @see malloc(3)
 */
void *test_malloc(size_t size);
#else
#define test_malloc(size) _test_malloc(size, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Test function overriding calloc.
 *
 * The memory is set to zero.
 *
 * @param[in]  nmemb  The number of elements for an array to be allocated.
 *
 * @param[in]  size   The size in bytes of each array element to allocate.
 *
 * @return A pointer to the allocated memory, NULL on error.
 *
 * @see calloc(3)
 */
void *test_calloc(size_t nmemb, size_t size);
#else
#define test_calloc(num, size) _test_calloc(num, size, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Test function overriding realloc which detects buffer overruns
 *        and memoery leaks.
 *
 * @param[in]  ptr   The memory block which should be changed.
 *
 * @param[in]  size  The bytes which should be allocated.
 *
 * @return           The newly allocated memory block, NULL on error.
 */
void *test_realloc(void *ptr, size_t size);
#else
#define test_realloc(ptr, size) _test_realloc(ptr, size, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Test function overriding free(3).
 *
 * @param[in]  ptr  The pointer to the memory space to free.
 *
 * @see free(3).
 */
void test_free(void *ptr);
#else
#define test_free(ptr) _test_free(ptr, __FILE__, __LINE__)
#endif

/* Redirect malloc, calloc and free to the unit test allocators. */
#ifdef UNIT_TESTING
#define malloc test_malloc
#define realloc test_realloc
#define calloc test_calloc
#define free test_free
#endif /* UNIT_TESTING */

/** @} */


/**
 * @defgroup cmocka_mock_assert Standard Assertions
 * @ingroup cmocka
 *
 * How to handle assert(3) of the standard C library.
 *
 * Runtime assert macros like the standard C library's assert() should be
 * redefined in modules being tested to use cmocka's mock_assert() function.
 * Normally mock_assert() signals a test failure. If a function is called using
 * the expect_assert_failure() macro, any calls to mock_assert() within the
 * function will result in the execution of the test. If no calls to
 * mock_assert() occur during the function called via expect_assert_failure() a
 * test failure is signalled.
 *
 * @{
 */

/**
 * @brief Function to replace assert(3) in tested code.
 *
 * In conjuction with check_assert() it's possible to determine whether an
 * assert condition has failed without stopping a test.
 *
 * @param[in]  result  The expression to assert.
 *
 * @param[in]  expression  The expression as string.
 *
 * @param[in]  file  The file mock_assert() is called.
 *
 * @param[in]  line  The line mock_assert() is called.
 *
 * @code
 * #ifdef UNIT_TESTING
 * extern void mock_assert(const int result, const char* const expression,
 *                         const char * const file, const int line);
 *
 * #undef assert
 * #define assert(expression) \
 *     mock_assert((int)(expression), #expression, __FILE__, __LINE__);
 * #endif
 *
 * void increment_value(int * const value) {
 *     assert(value);
 *     (*value) ++;
 * }
 * @endcode
 *
 * @see assert(3)
 * @see expect_assert_failure
 */
void mock_assert(const int result, const char* const expression,
                 const char * const file, const int line);

#ifdef DOXYGEN
/**
 * @brief Ensure that mock_assert() is called.
 *
 * If mock_assert() is called the assert expression string is returned.
 *
 * @param[in]  fn_call  The function will will call mock_assert().
 *
 * @code
 * #define assert mock_assert
 *
 * void showmessage(const char *message) {
 *   assert(message);
 * }
 *
 * int main(int argc, const char* argv[]) {
 *   expect_assert_failure(show_message(NULL));
 *   printf("succeeded\n");
 *   return 0;
 * }
 * @endcode
 *
 */
void expect_assert_failure(function fn_call);
#else
#define expect_assert_failure(function_call) \
  { \
    const int result = setjmp(global_expect_assert_env); \
    global_expecting_assert = 1; \
    if (result) { \
      print_message("Expected assertion %s occurred\n", \
                    global_last_failed_assert); \
      global_expecting_assert = 0; \
    } else { \
      function_call ; \
      global_expecting_assert = 0; \
      print_error("Expected assert in %s\n", #function_call); \
      _fail(__FILE__, __LINE__); \
    } \
  }
#endif

/** @} */

/* Function prototype for setup, test and teardown functions. */
typedef void (*UnitTestFunction)(void **state);

/* Function that determines whether a function parameter value is correct. */
typedef int (*CheckParameterValue)(const LargestIntegralType value,
                                   const LargestIntegralType check_value_data);

/* Type of the unit test function. */
typedef enum UnitTestFunctionType {
    UNIT_TEST_FUNCTION_TYPE_TEST = 0,
    UNIT_TEST_FUNCTION_TYPE_SETUP,
    UNIT_TEST_FUNCTION_TYPE_TEARDOWN,
    UNIT_TEST_FUNCTION_TYPE_GROUP_SETUP,
    UNIT_TEST_FUNCTION_TYPE_GROUP_TEARDOWN,
} UnitTestFunctionType;

/*
 * Stores a unit test function with its name and type.
 * NOTE: Every setup function must be paired with a teardown function.  It's
 * possible to specify NULL function pointers.
 */
typedef struct UnitTest {
    const char* name;
    UnitTestFunction function;
    UnitTestFunctionType function_type;
} UnitTest;

typedef struct GroupTest {
    UnitTestFunction setup;
    UnitTestFunction teardown;
    const UnitTest *tests;
    const size_t number_of_tests;
} GroupTest;

/* Function prototype for test functions. */
typedef void (*CMUnitTestFunction)(void **state);

/* Function prototype for setup and teardown functions. */
typedef int (*CMFixtureFunction)(void **state);

struct CMUnitTest {
    const char *name;
    CMUnitTestFunction test_func;
    CMFixtureFunction setup_func;
    CMFixtureFunction teardown_func;
    void *initial_state;
};

/* Location within some source code. */
typedef struct SourceLocation {
    const char* file;
    int line;
} SourceLocation;

/* Event that's called to check a parameter value. */
typedef struct CheckParameterEvent {
    SourceLocation location;
    const char *parameter_name;
    CheckParameterValue check_value;
    LargestIntegralType check_value_data;
} CheckParameterEvent;

/* Used by expect_assert_failure() and mock_assert(). */
extern int global_expecting_assert;
//extern jmp_buf global_expect_assert_env;
extern const char * global_last_failed_assert;

/* Retrieves a value for the given function, as set by "will_return". */
LargestIntegralType _mock(const char * const function, const char* const file,
                          const int line);

void _expect_function_call(
    const char * const function_name,
    const char * const file,
    const int line,
    const int count);

void _function_called(const char * const function, const char* const file,
                          const int line);

void _expect_check(
    const char* const function, const char* const parameter,
    const char* const file, const int line,
    const CheckParameterValue check_function,
    const LargestIntegralType check_data, CheckParameterEvent * const event,
    const int count);

void _expect_in_set(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const LargestIntegralType values[],
    const size_t number_of_values, const int count);
void _expect_not_in_set(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const LargestIntegralType values[],
    const size_t number_of_values, const int count);

void _expect_in_range(
    const char* const function, const char* const parameter,
    const char* const file, const int line,
    const LargestIntegralType minimum,
    const LargestIntegralType maximum, const int count);
void _expect_not_in_range(
    const char* const function, const char* const parameter,
    const char* const file, const int line,
    const LargestIntegralType minimum,
    const LargestIntegralType maximum, const int count);

void _expect_value(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const LargestIntegralType value,
    const int count);
void _expect_not_value(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const LargestIntegralType value,
    const int count);

void _expect_string(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const char* string,
    const int count);
void _expect_not_string(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const char* string,
    const int count);

void _expect_memory(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const void* const memory,
    const size_t size, const int count);
void _expect_not_memory(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const void* const memory,
    const size_t size, const int count);

void _expect_any(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const int count);

void _check_expected(
    const char * const function_name, const char * const parameter_name,
    const char* file, const int line, const LargestIntegralType value);

void _will_return(const char * const function_name, const char * const file,
                  const int line, const LargestIntegralType value,
                  const int count);
void _assert_true(const LargestIntegralType result,
                  const char* const expression,
                  const char * const file, const int line);
void _assert_return_code(const LargestIntegralType result,
                         size_t rlen,
                         const LargestIntegralType error,
                         const char * const expression,
                         const char * const file,
                         const int line);
void _assert_int_equal(
    const LargestIntegralType a, const LargestIntegralType b,
    const char * const file, const int line);
void _assert_int_not_equal(
    const LargestIntegralType a, const LargestIntegralType b,
    const char * const file, const int line);
void _assert_string_equal(const char * const a, const char * const b,
                          const char * const file, const int line);
void _assert_string_not_equal(const char * const a, const char * const b,
                              const char *file, const int line);
void _assert_memory_equal(const void * const a, const void * const b,
                          const size_t size, const char* const file,
                          const int line);
void _assert_memory_not_equal(const void * const a, const void * const b,
                              const size_t size, const char* const file,
                              const int line);
void _assert_in_range(
    const LargestIntegralType value, const LargestIntegralType minimum,
    const LargestIntegralType maximum, const char* const file, const int line);
void _assert_not_in_range(
    const LargestIntegralType value, const LargestIntegralType minimum,
    const LargestIntegralType maximum, const char* const file, const int line);
void _assert_in_set(
    const LargestIntegralType value, const LargestIntegralType values[],
    const size_t number_of_values, const char* const file, const int line);
void _assert_not_in_set(
    const LargestIntegralType value, const LargestIntegralType values[],
    const size_t number_of_values, const char* const file, const int line);

void* _test_malloc(const size_t size, const char* file, const int line);
void* _test_realloc(void *ptr, const size_t size, const char* file, const int line);
void* _test_calloc(const size_t number_of_elements, const size_t size,
                   const char* file, const int line);
void _test_free(void* const ptr, const char* file, const int line);

void _fail(const char * const file, const int line);

void _skip(const char * const file, const int line);

int _run_test(
    const char * const function_name, const UnitTestFunction Function,
    void ** const volatile state, const UnitTestFunctionType function_type,
    const void* const heap_check_point);
CMOCKA_DEPRECATED int _run_tests(const UnitTest * const tests,
                                 const size_t number_of_tests);
CMOCKA_DEPRECATED int _run_group_tests(const UnitTest * const tests,
                                       const size_t number_of_tests);

/* Test runner */
int _cmocka_run_group_tests(const char *group_name,
                            const struct CMUnitTest * const tests,
                            const size_t num_tests,
                            CMFixtureFunction group_setup,
                            CMFixtureFunction group_teardown);

/* Standard output and error print methods. */
void print_message(const char* const format, ...) CMOCKA_PRINTF_ATTRIBUTE(1, 2);
void print_error(const char* const format, ...) CMOCKA_PRINTF_ATTRIBUTE(1, 2);
void vprint_message(const char* const format, va_list args) CMOCKA_PRINTF_ATTRIBUTE(1, 0);
void vprint_error(const char* const format, va_list args) CMOCKA_PRINTF_ATTRIBUTE(1, 0);

enum cm_message_output {
    CM_OUTPUT_STDOUT,
    CM_OUTPUT_SUBUNIT,
    CM_OUTPUT_TAP,
    CM_OUTPUT_XML,
};

/**
 * @brief Function to set the output format for a test.
 *
 * The ouput format for the test can either be set globally using this
 * function or overriden with environment variable CMOCKA_MESSAGE_OUTPUT.
 *
 * The environment variable can be set to either STDOUT, SUBUNIT, TAP or XML.
 *
 * @param[in] output    The output format to use for the test.
 *
 */
void cmocka_set_message_output(enum cm_message_output output);

/** @} */

#endif /* CMOCKA_H_ */
/**
 * @brief 
 * 
 * @file BB_Led.h
 * @author Gunj Manseta
 * @date 2018-03-10
 */

#ifndef BB_LED_H
#define BB_LED_H

typedef enum
{
    LED0,
    LED1,
    LED2,
    LED3
}USER_LED_T;

/**
 * @brief 
 * 
 * @param lednum 
 * @return int 
 */
int BB_LedON(USER_LED_T lednum);

/**
 * @brief 
 * 
 * @param lednum 
 * @return int 
 */
int BB_LedOFF(USER_LED_T lednum);

/**
 * @brief 
 * 
 * @param lednum 
 * @return int 
 */
int BB_LedDefault();

#endif/**
 * @brief 
 * 
 * @file tmp102_sensor.h
 * @author Gunj Manseta
 * @date 2018-03-13
 */
#ifndef TMP102SENSOR_H
#define TMP102SENSOR_H


#define TMP102_SLAVE_ADDR           (0x48)


/* Register address */
#define TMP102_REG_TEMPERATURE          (0x00) 
#define TMP102_REG_CONFIGURATION        (0x01)  
#define TMP102_REG_TLOW                 (0x02)
#define TMP102_REG_THIGH                (0x03)  



#define TMP102_CONFIG_SD                (1)
#define TMP102_CONFIG_TM                (1<<1)
#define TMP102_CONFIG_POL               (1<<2) 
#define TMP102_CONFIG_EM                (1<<12)
#define TMP102_CONFIG_AL                (1<<13)
#define TMP102_CONFIG_CR(x)             (x<<14)
            
#define TMP102_CONFIG_FAULTBITS                (3<<3)              /*generates alert after 4 consecutive faults*/
#define TMP102_CONFIG_ONESHOT_CR               (1<7)              /*saves power between conversions when 1*/ 

typedef enum temperature_unit
{
    CELCIUS = 0,
    FAHREN,
    KELVIN

}TEMPERATURE_UNIT_T;

typedef struct
{
    ///* (D)0 = Continuous conversion; 1 = Can sleep*/
    uint16_t SD_MODE:1;
    ///* (D)0 = Comparatore mode; 1 = Interrupt mode*/
    uint16_t TM_MODE:1;
    ///* (D)0 = ALERT pin becomes active low; 1 = ALERT pin becomes active high and the state of the ALERT pin is inverted. */
    uint16_t POL:1;
    ///* (D)0 = 1Fault; 1= 2Faults; 3 = 4Faults; 4=6Faults */
    uint16_t FAULT:2;
    const uint16_t RES0:2;
    ///* (D)0 =  During the conversion, the OS bit reads '0'; 1 = writing a 1 to the OS bit starts a single temperature conversion */
    uint16_t OS:1;
    const uint16_t RES1:4;
    ///* (D)0 = Normal mode(12bit); 1= Extended mode(13 bit) */
    uint16_t EM_MODE:1;
    ///*  Reads the AL bit*/
    const uint16_t RO_AL_MODE:1;
    ///* 0 = 0.25Hz ; 1 = 1Hz ; (D)2 = 4Hz ; 3 = 8Hz */
    uint16_t CR:2;

}TMP102_CONFIG_REG_SETTINGS_T;

#define TMP102_CONFIG_DEFAULT_ASSIGN \
{\
    .SD_MODE = 0,\
    .TM_MODE = 0,\
    .POL     = 0,\
    .OS      = 0,\
    .EM_MODE = 0,\
    .CR      = 2\
}

extern const TMP102_CONFIG_REG_SETTINGS_T TMP102_CONFIG_DEFAULT;

int TMP102_setMode(TMP102_CONFIG_REG_SETTINGS_T mode);

/**
 * @brief Brings back to default
 * 
 * @return int 
 */
int TMP102_setmode_allDefault();

/**
 * @brief Gives a memdump of 4 len. 
 *  **IMP** must free the address using return pointer 
 * @return uint8_t* 
 */
uint16_t* TMP102_memDump();

/**
 * @brief Abstracted macros for different units
 * 
 */
#define TMP102_getTemp_Celcius(p_temp)  TMP102_getTemp(p_temp, CELCIUS)
#define TMP102_getTemp_Kelvin(p_temp)   TMP102_getTemp(p_temp, KELVIN)
#define TMP102_getTemp_Fahren(p_temp)   TMP102_getTemp(p_temp, FAHREN)


/**
 * @brief Gets the temperature value
 * 
 * @param temp 
 * @param unit 
 * @return int 
 */
int TMP102_getTemp(float *temp, TEMPERATURE_UNIT_T unit);

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_SD_PowerSaving();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_SD_Continuous_default();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_TM_ComparatorMode_default();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_TM_InterruptMode();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_ALERT_ActiveLow_default();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_ALERT_ActiveHigh();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_EM_NormalMode_default();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_EM_ExtendedMode();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_CR_250mHZ();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_CR_1HZ();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_CR_4HZ_default();

/**
 * @brief 
 * 
 * @return int 
 */
int TMP102_setMode_CR_8HZ();

/**
 * @brief 
 * 
 * @param al_bit 
 * @return int 
 */
int TMP102_readMode_ALERT(uint8_t *al_bit);

/**
 * @brief 
 * 
 * @param tlow_C 
 * @return int 
 */
int TMP102_write_Tlow(float tlow_C);

/**
 * @brief 
 * 
 * @param thigh_C 
 * @return int 
 */
int TMP102_write_Thigh(float thigh_C);

/**
 * @brief 
 * 
 * @param tlow_C 
 * @return int 
 */
int TMP102_read_Tlow(float *tlow_C);

/**
 * @brief 
 * 
 * @param thigh_C 
 * @return int 
 */
int TMP102_read_Thigh(float *thigh_C);


#endif/**
 * @brief 
 * 
 * @file my_i2c.h
 * @author Gunj Manseta
 * @date 2018-03-13
 */
#ifndef MYI2C_H
#define MYI2C_H

#include <pthread.h>
#include "mraa/i2c.h"

#define BB_I2C_BUS_2  (2)

/**
 * @brief This is the handle for I2C mster and each master should have only one handle
 * 
 */
typedef struct i2c_handle
{
    /* This context is a typedef'ed pointer within */
    mraa_i2c_context i2c_context;
    pthread_spinlock_t handle_lock;

}I2C_MASTER_HANDLE_T;

/**
 * @brief Get the MasterI2C handle object
 * 
 * @return I2C_MASTER_HANDLE_T *
 */
I2C_MASTER_HANDLE_T* getMasterI2C_handle();

/**
 * @brief Prints the error code string to stdout
 * 
 * @param errorCode 
 */
void printErrorCode(int errorCode);

/**
 * @brief Inits the I2C master handle
 * There is an internal state of the context which is maintained which gets updated with every init call
 * Internal context goes to NULL is error in init
 * This context points to the new handle that is passed as the parameter
 * @param handle 
 * @return int SUCCESS=0 and ERROR =-1
 */
int I2Cmaster_Init(I2C_MASTER_HANDLE_T *handle);

/**
 * @brief 
 * 
 * @param handle 
 * @return int 
 */
int I2Cmaster_Destroy(I2C_MASTER_HANDLE_T *handle);

/**
 * @brief 
 * 
 * @param slave_addr 
 * @param reg_addr 
 * @param data 
 * @return int 
 */
int I2Cmaster_read_byte(uint8_t slave_addr, uint8_t reg_addr, uint8_t *data);

/**
 * @brief 
 * 
 * @param slave_addr 
 * @param reg_addr 
 * @param data 
 * @param len 
 * @return int 
 */
int I2Cmaster_read_bytes(uint8_t slave_addr, uint8_t reg_addr, uint8_t *data, size_t len);


/**
 * @brief Writes a byte/pointer register to the slave
 * 
 * @param slave_addr 
 * @param reg_addr 
 * @return int 
 */
int I2Cmaster_write(uint8_t slave_addr, uint8_t reg_addr);

/**
 * @brief 
 * 
 * @param slave_addr 
 * @param reg_addr 
 * @param data 
 * @return int 
 */
int I2Cmaster_write_byte(uint8_t slave_addr, uint8_t reg_addr, uint8_t data);

/**
 * @brief 
 * 
 * @param slave_addr 
 * @param reg_addr 
 * @param data 
 * @param len 
 * @return int 
 */
int I2Cmaster_write_bytes(uint8_t slave_addr, uint8_t reg_addr, uint8_t *data, size_t len);

/**
 * @brief 
 * 
 * @param slave_addr 
 * @param reg_addr 
 * @param data 
 * @param lsb_first 
 * @return int 
 */
int I2Cmaster_write_word(uint8_t slave_addr, uint8_t reg_addr, uint16_t data, uint8_t lsb_first);



#endif/**
 * @brief 
 * 
 * @file apds9301_sensor.h
 * @author Gunj Manseta
 * @date 2018-03-13
 */


#ifndef APDS9301SENSOR_H
#define APDS9301SENSOR_H

#include <stdint.h>

#define APDS9301_SLAVE_ADDR     (0x39)

#define APDS9301_CMD_REG        (0x80)
#define APDS9301_CMD_WORD_EN    (1<<5)
#define APDS9301_CMD_INT_CLEAR  (1<6)

/* REGISTERS */
#define APDS9301_CTRL_REG           (0x00) | APDS9301_CMD_REG
#define APDS9301_TIMING_REG         (0x01) | APDS9301_CMD_REG
#define APDS9301_ID_REG             (0x0A) | APDS9301_CMD_REG
#define APDS9301_INT_CTRL_REG       (0x06) | APDS9301_CMD_REG
#define APDS9301_CH0_DATALOW        (0x0C) | APDS9301_CMD_REG
#define APDS9301_CH0_DATAHIGH       (0x0D) | APDS9301_CMD_REG
#define APDS9301_CH1_DATALOW        (0x0E) | APDS9301_CMD_REG
#define APDS9301_CH1_DATAHIGH       (0x0F) | APDS9301_CMD_REG
#define APDS9301_INT_TH_LL_REG      (0x02) | APDS9301_CMD_REG 
#define APDS9301_INT_TH_LH_REG      (0x03) | APDS9301_CMD_REG
#define APDS9301_INT_TH_HL_REG      (0x04) | APDS9301_CMD_REG
#define APDS9301_INT_TH_HH_REG      (0x05) | APDS9301_CMD_REG


/* Bit fields in Registers */
#define APDS9301_CTRL_POWERON       (0x03)   
#define APDS9301_CTRL_POWEROFF      (0x00)
#define APDS9301_INTCTRL_IEN        (1<<4)   
#define APDS9301_TIMING_GAIN        (1<<4)
#define APDS9301_TIMING_INTEG(x)    (x)
#define APDS9301_TIMING_MANUAL(x)   (x<<3)


#define  APDS9301_mode_interruptEnable()            APDS9301_mode_interrupt(1)
#define  APDS9301_mode_interruptDisable_default()   APDS9301_mode_interrupt(0)

#define APDS9301_mode_integrationTime0()            APDS9301_mode_integrationTime(0)    
#define APDS9301_mode_integrationTime1()            APDS9301_mode_integrationTime(1)
#define APDS9301_mode_integrationTime2_default()    APDS9301_mode_integrationTime(2)
#define APDS9301_mode_integrationTime3()            APDS9301_mode_integrationTime(3)

#define APDS9301_mode_manualcontrolON()             APDS9301_mode_manualcontrol(1)
#define APDS9301_mode_manualcontrolOFF_default()    APDS9301_mode_manualcontrol(0)


/**
 * @brief Sets back the default configration of the sensor
 * 
 * @return int 
 */
int APDS9301__setmode_allDefault();

/**
 * @brief Gives a memdump of 15 len. 
 *  **IMP** must free the address using return pointer 
 * @return uint8_t* 
 */
uint8_t* APDS9301_memDump();

/**
 * @brief 
 * 
 * @param thlow 
 * @return int 
 */
int APDS9301_write_ThLow(uint16_t thlow);

/**
 * @brief 
 * 
 * @param thhigh 
 * @return int 
 */
int APDS9301_write_ThHigh(uint16_t thhigh);

/**
 * @brief 
 * 
 * @param thlow 
 * @return int 
 */
int APDS9301_read_ThLow(uint16_t *thlow);

/**
 * @brief 
 * 
 * @param thhigh 
 * @return int 
 */
int APDS9301_read_ThHigh(uint16_t *thhigh);

/**
 * @brief 
 * 
 * @param ctrl_reg 
 * @return int 
 */
int APDS9301_readControlReg(uint8_t *ctrl_reg);

/**
 * @brief 
 * 
 * @return int 
 */
int APDS9301_mode_highGain();

/**
 * @brief 
 * 
 * @return int 
 */
int APDS9301_mode_lowGain_default();

/**
 * @brief 
 * 
 * @param on 
 * @return int 
 */
int APDS9301_mode_manualcontrol(uint8_t on);

/**
 * @brief 
 * 
 * @param x 
 * @return int 
 */
int APDS9301_mode_integrationTime(uint8_t x);

/**
 * @brief 
 * 
 * @param enable 
 * @return int 
 */
int APDS9301_mode_interrupt(uint8_t enable);

/**
 * @brief 
 * 
 * @return int 
 */
int APDS9301_clearPendingInterrupt();


/**
 * @brief 
 * 
 * @return int 
 */
int APDS9301_poweron();

/**
 * @brief 
 * 
 * @return int 
 */
int APDS9301_powerdown();

/**
 * @brief 
 * 
 * @param id 
 * @return int 
 */
int APDS9301_readID(uint8_t *id);

/**
 * @brief 
 * 
 * @param ch0_data 
 * @return int 
 */
int APDS9301_readCh0(uint16_t *ch0_data);

/**
 * @brief 
 * 
 * @param ch1_data 
 * @return int 
 */
int APDS9301_readCh1(uint16_t *ch1_data);

/**
 * @brief 
 * 
 * @return float 
 */
float APDS9301_getLux();

/**
 * @brief 
 * 
 * @return int 
 */
int APDS9301_test();


#endif/**
 * @brief Test for the APDS9301 sensor
 * 
 * @file apds9301_testmain.c
 * @author Gunj Manseta
 * @date 2018-03-14
 */

#include "my_i2c.h"
#include "apds9301_sensor.h"
#include <unistd.h>

int main()
{
    I2C_MASTER_HANDLE_T i2c;
    int ret = 0;
    if(ret = I2Cmaster_Init(&i2c) !=0)
    {
        printErrorCode(ret);
        printf("[ERROR] I2C Master init failed\n"); 
    }

    ret = APDS9301_poweron();
    if(ret == 0) printf("Sensor ON\n");
    uint8_t sensor_id = 0x50;
    uint8_t data = 0;
    ret  = APDS9301_readControlReg(&data);
    if(ret == 0) printf("CTRL REG: %x\n",data);

    uint16_t tlow;
    ret = APDS9301_read_ThLow(&tlow);
    if(ret == 0) printf("READ TLOW 0x%x\n",tlow);

    tlow = 0xBB11;
    ret = APDS9301_write_ThLow(tlow);
    if(ret == 0) printf("WRITE TLOW 0x%x\n",tlow);

    tlow = 0xaaaa;
    ret = APDS9301_read_ThLow(&tlow);
    if(ret == 0) printf("READ TLOW 0x%x\n",tlow);
    
    ret = APDS9301_mode_highGain();
    if(ret != 0) printf("ERROR\n");

    uint8_t *memdump = APDS9301_memDump();
    printf("----SENSOR DUMP-----\n");
    for(uint8_t i = 0; i < 15; i++)
        printf("%02dh : 0x%x\n",i,memdump[i]);
    free(memdump);
    printf("---------\n");

    ret = APDS9301_mode_lowGain_default();
    if(ret != 0) printf("ERROR\n");

    ret = APDS9301_readID(&data);
    if(ret == 0) printf("expected: %x ID: %x\n",sensor_id, data);

    while(1)
    {
        float lux = APDS9301_getLux();
        if(lux < 0) printf("Error. Lux is negative\n");
        else    printf("Lux: %f\n",lux);
        sleep(2);
    }
    
    if(ret = I2Cmaster_Destroy(&i2c) !=0)
    {
        printErrorCode(ret);
        printf("[ERROR] I2C Master destroy failed\n"); 
    }

}
/**
 * @brief Test for the APDS9301 sensor
 * 
 * @file apds9301_testmain.c
 * @author Gunj Manseta
 * @date 2018-03-14
 */

#include "my_i2c.h"
#include "apds9301_sensor.h"
#include <unistd.h>
#include "cmocka.h"

void testAPDS9301(void **state)
{
    I2C_MASTER_HANDLE_T i2c;
    int ret = 0;
    ret = I2Cmaster_Init(&i2c);
    assert_int_equal(ret, 0);
    assert_non_null((void*)getMasterI2C_handle());
    assert_ptr_equal(&i2c,getMasterI2C_handle());
    
    ret = APDS9301_poweron();
    assert_int_equal(ret, 0);

    ret = APDS9301_test();
    assert_int_equal(ret, 0);

    uint8_t data = 0;
    ret  = APDS9301_readControlReg(&data);
    assert_int_equal(ret, 0);
    assert_int_equal((data & 0x3), 0x03);


    uint16_t tlow = 0xBB11;
    ret = APDS9301_write_ThLow(tlow);
    assert_int_equal(ret, 0);

    tlow = 0;
    ret = APDS9301_read_ThLow(&tlow);
    assert_int_equal(ret, 0);
    assert_int_equal(tlow, 0xBB11);

    uint16_t thigh = 0xA5A5;
    ret = APDS9301_write_ThHigh(thigh);
    assert_int_equal(ret, 0);

    thigh = 0 ; 
    ret = APDS9301_read_ThHigh(&thigh);
    assert_int_equal(ret, 0);
    assert_int_equal(thigh, 0xA5A5);
    
    
    ret = APDS9301_mode_highGain();
    assert_int_equal(ret, 0);

    ret = APDS9301_mode_integrationTime3();
    assert_int_equal(ret, 0);

    ret = APDS9301_mode_interruptEnable();
    assert_int_equal(ret, 0);

    ret = APDS9301_mode_manualcontrolON();
    assert_int_equal(ret, 0);

    uint8_t *memdump = APDS9301_memDump();

    assert_non_null(memdump);

    /* Power up bits */
    assert_int_equal(memdump[0] & 0x3, 0x3);

    /* Timing register */
    assert_int_equal(memdump[1] & 0x1B, 0x1B);
    
    /* Interrupt control reg */
    assert_int_equal(memdump[6] & 0x3F, 0x10);

    free(memdump);

    // ret = APDS9301_mode_lowGain_default();
    // assert_int_equal(ret, 0);

    // ret = APDS9301_mode_integrationTime2_default();
    // assert_int_equal(ret, 0);

    // ret = APDS9301_mode_interruptDisable_default();
    // assert_int_equal(ret, 0);

    // ret = APDS9301_mode_manualcontrolOFF_default();
    // assert_int_equal(ret, 0);

    ret = APDS9301__setmode_allDefault();
    assert_int_equal(ret, 0);

    ret = APDS9301_readID(&data);
    assert_int_equal(data&0xF0, 0x50);

    int i = 0;
    while(i<2)
    {
        float lux = APDS9301_getLux();
        assert_int_not_equal(lux, -1);
        assert_in_range(lux,0,100);

        i++;
    }
    
    ret = APDS9301_powerdown();
    assert_int_equal(ret, 0);

    ret = APDS9301_readControlReg(&data);
    assert_int_equal(ret, 0);
    assert_int_equal((data & 0x3), 0);

    ret = I2Cmaster_Destroy(&i2c);
    assert_int_equal(ret, 0);
    assert_null((void*)getMasterI2C_handle());

}


int main()
{
    const struct CMUnitTest tests[] = {	
	
    cmocka_unit_test(testAPDS9301)
    
	};

	return cmocka_run_group_tests(tests, NULL, NULL);

}/**
 * @brief 
 * 
 * @file LED_test.c
 * @author Gunj Manseta
 * @date 2018-03-10
 */

#include <stdio.h>
#include <unistd.h>
#include "BB_Led.h"


int main()
{
    if(!BB_LedON(1))
        printf("LED ON\n");
    sleep(5);
    if(!BB_LedOFF(1))
        printf("LED OFF\n");
    return 0;
}#include <sys/socket.h>
#include <unistd.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <string.h>
#include <stdio.h>
#include <arpa/inet.h>

#include "sensor_common_object.h"

//#define PORT 3000
//#define IP "127.0.0.1"
//#define IP "192.168.1.238"
#define LOG(format, ...) printf(format, ##__VA_ARGS__)

void printResponse(REMOTE_RESPONSE_T rsp);

int main()
{
    struct sockaddr_in addr, server_addr = {0};
    uint16_t PORT = 3000;
    char IP[20] = "127.0.0.1";

    int client_socket = 0;
    REMOTE_REQUEST_T req = {0};
    REMOTE_RESPONSE_T rsp = {0};

    if ((client_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        LOG("[ERROR] Socket creation\n");
        return -1;
    }
  
    LOG("[INFO] Socket Created\n");

    //memset(&server_addr, 0, sizeof(server_addr));
  
    server_addr.sin_family = AF_INET;

    LOG("***CLIENT APPLICATION***\n");
    LOG("Default IP:%s PORT%u\n",IP,PORT);
    LOG("Enter new IP and Port?(y/n)->");
    char ans;
    scanf(" %c",&ans);
    if(ans == 'y' || ans == 'Y')
    {
        LOG("Enter Port number ->");
        scanf(" %hu",&PORT);
        LOG("Enter IP addr ->");
        scanf("%s",IP);
        //fgets(IP, 20, stdin);
    }

    server_addr.sin_port = htons(PORT);
      
    /* We need this to convert the IP ADDR in proper format */
    if(inet_pton(AF_INET, IP, &server_addr.sin_addr)<=0) 
    {
        LOG("[ERROR] Invalid address\n");
        return -1;
    }

    LOG("Continue?(y/n)->");
    scanf(" %c",&ans);
    if(ans == 'n' || ans == 'N')
        exit(0);

    if (connect(client_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        LOG("[ERROR] Connection Failed \n");
        return -1;
    }
    int i = 0, nbytes;
    int continue_flag = 1;
    do{

        req.request_id = GET_TEMP_C + i%5;
        /*Sending the payload */
        nbytes = send(client_socket , (char*)&req , sizeof(req), 0 );
        if(nbytes < sizeof(req))
        {
            LOG("[ERROR] Cannot send complete data\n");
            return 1;
        }

        LOG("[INFO] Number of bytes sent: %d\n",nbytes);
        
        nbytes=0;
        do{
            nbytes = recv(client_socket, (((char*)&(rsp))+nbytes), sizeof(rsp), 0);
        }while(nbytes < sizeof(rsp) && nbytes != -1);

        LOG("[INFO] Receivced bytes: %d\n",nbytes);

        LOG("\n***SERVER RESPONSE***\n");
        printResponse(rsp);
        LOG("\n*********************\n");

        LOG("Continue?(y/n)->");
        scanf(" %c",&ans);
        if(ans == 'n' || ans == 'N')
            continue_flag = 0;
        
        i++;
    }while(continue_flag);

    // req.request_id = CONN_CLOSE_REQ;
    req.request_id = CONN_KILL_APP_REQ;
    nbytes = send(client_socket , (char*)&req , sizeof(req), 0 );
    if(nbytes < sizeof(req))
    {
        LOG("[ERROR] Cannot send complete data\n");
        return 1;
    }

    LOG("[INFO] Number of bytes sent: %d\n",nbytes);

    close(client_socket);

    LOG("[INFO] Connection closed;\n");
    return 0;
}

void printResponse(REMOTE_RESPONSE_T rsp)
{
    switch(rsp.rsp_id)
    {
        case(GET_FUNC):
            LOG("%s",rsp.metadata);
            break;
        case(GET_TEMP_C):
            LOG("degree C : %0.3f\n",rsp.data.floatingData);
            break;
        case(GET_TEMP_F):
            LOG("degree F : %0.3f\n",rsp.data.floatingData);
            break;
        case(GET_TEMP_K):
            LOG("degree K : %0.3f\n",rsp.data.floatingData);
            break;
        case(GET_LUX):
            LOG("LUX : %0.3f\n",rsp.data.floatingData);
            break;
        case(GET_DAY_NIGHT):
            LOG("It is %s now\n",((rsp.data.isNight == 0) ? "DAY" : "NIGHT"));
            break;
        // case(CONN_CLOSE_RSP):
        //     break;
        default:
            break;

    }
}/**
 * @brief Test for tmp102 sensor
 * 
 * @file tmp102_testmain.c
 * @author Gunj Manseta
 * @date 2018-03-14
 */

#include "my_i2c.h"
#include "tmp102_sensor.h"
#include <unistd.h>
#include "cmocka.h"

I2C_MASTER_HANDLE_T i2c;



static void testTMP102(void **state)
{
    int ret = I2Cmaster_Init(&i2c);
    assert_int_equal(ret, 0);
    assert_non_null((void*)getMasterI2C_handle());
    assert_ptr_equal(&i2c,getMasterI2C_handle());

    uint16_t *memdump = TMP102_memDump();
    assert_non_null(memdump);
    // printf("----1.SENSOR DUMP-----\n");
    // for(uint8_t i = 0; i < 4; i++)
    // {
    //     (i == 1) ? assert_int_equal(memdump[i], 0x60a0): 0;
    //     (i == 2) ? assert_int_equal(memdump[i], 0x4b00): 0;
    //     (i == 3) ? assert_int_equal(memdump[i], 0x5000): 0;
    //     printf("%02dh : 0x%x\n",i,memdump[i]);
    // }
    // printf("---------\n");

    assert_int_equal(memdump[1], 0x60a0);
    assert_int_equal(memdump[2], 0x4b00);
    assert_int_equal(memdump[3], 0x5000);

    free(memdump);

    ret = TMP102_setMode_ALERT_ActiveHigh();
    assert_int_equal(ret, 0);
    ret = TMP102_setMode_CR_8HZ();
    assert_int_equal(ret, 0);
    ret = TMP102_setMode_SD_PowerSaving();
    assert_int_equal(ret, 0);
    ret = TMP102_setMode_TM_InterruptMode();
    assert_int_equal(ret, 0);
    ret = TMP102_setMode_EM_ExtendedMode();
    assert_int_equal(ret, 0);


    memdump = TMP102_memDump();
    assert_non_null(memdump);
    // printf("----2.SENSOR DUMP-----\n");
    // for(uint8_t i = 0; i < 4; i++)
    // {
    //     (i == 1) ? assert_int_equal(memdump[i], 0x67d0): 0;
    //     (i == 2) ? assert_int_equal(memdump[i], 0x4b00): 0;
    //     (i == 3) ? assert_int_equal(memdump[i], 0x5000): 0;
    //     printf("%02dh : 0x%x\n",i,memdump[i]);
    // }
    // printf("---------\n");

    assert_int_equal(memdump[1], 0x67d0);
    assert_int_equal(memdump[2], 0x4b00);
    assert_int_equal(memdump[3], 0x5000);

    free(memdump);


    
    ret = TMP102_setmode_allDefault();
    assert_int_equal(ret, 0);

    memdump = TMP102_memDump();
    // printf("----3.SENSOR DUMP-----\n");
    // for(uint8_t i = 0; i < 4; i++)
    // {
    //     (i == 1) ? assert_int_equal(memdump[i], 0x60a0): 0;
    //     (i == 2) ? assert_int_equal(memdump[i], 0x4b00): 0;
    //     (i == 3) ? assert_int_equal(memdump[i], 0x5000): 0;
    
    //     printf("%02dh : 0x%x\n",i,memdump[i]);
    // }
    // printf("---------\n");

    assert_int_equal(memdump[1], 0x60a0);
    assert_int_equal(memdump[2], 0x4b00);
    assert_int_equal(memdump[3], 0x5000);

    /* Checking the Tlow = 75deg C and Thigh 80deg C */
    float temp = (float)(memdump[2]>>4) * 0.0625;
    assert_int_equal(temp,75.0);

    temp = (float)(memdump[3]>>4) * 0.0625;
    assert_int_equal(temp,80.0);

    free(memdump);

    float temperature = 0.0, celcius = 0.0f, dummy = 0.0;
    
    int i = 0;

    printf("\n---------TEMPERATURE VALUES--------------\n");
    while(i<3)
    {
		int ret = TMP102_getTemp_Celcius(&temperature);
        assert_int_equal(ret, 0);
		if(ret == 0) printf("C Temp: %.03f\n",temperature);
        celcius = temperature;

		ret = TMP102_getTemp_Fahren(&temperature);
        assert_int_equal(ret, 0);
        dummy = (celcius*1.8) + 32;
        assert_true(temperature == dummy);
		if(ret == 0) printf("F Temp: %.03f\n",temperature);

		ret = TMP102_getTemp_Kelvin(&temperature);
        assert_int_equal(ret, 0);
        dummy = celcius + 273.15;
        assert_true(temperature == dummy);
		if(ret == 0) printf("K Temp: %.03f\n",temperature);
	    
        i++;
        sleep(1);
    } 
    printf("------------------------------------------\n");


    ret = I2Cmaster_Destroy(&i2c);
    assert_int_equal(ret, 0);
    assert_null((void*)getMasterI2C_handle());

}


int main()
{
    const struct CMUnitTest tests[] = {	
	
    cmocka_unit_test(testTMP102)
    
	};

	return cmocka_run_group_tests(tests, NULL, NULL);

}/**
 * @brief 
 * 
 * @file logger_task.c
 * @author Gunj Manseta
 * @date 2018-03-09
 */

#include <pthread.h>
#include <fcntl.h>           /* For O_* constants */
#include <sys/stat.h>        /* For mode constants */
#include <mqueue.h>
#include <string.h>
#include <errno.h>

#include "main_task.h"
#include "logger_task.h"
#include "error_data.h"
#include "readConfiguration.h"

#define LOG_DIR     "./log/"
#define __LOG_PATH(x) LOG_DIR ## x
#define LOG_PATH(x) __LOG_PATH(x)

#define MQ_LOGGERTASK_NAME "/loggertask_queue"


/**
 * @brief USe it carefully as there is not NULL checking of the file stream provided
 * 
 */
#define LT_LOG(fp,format, ...) do{fprintf(fp,"[PID:%d][TID:%ld]",getpid(),syscall(SYS_gettid)); fprintf(fp,format, ##__VA_ARGS__); fflush(fp);}while(0)

/* Keeping the log level to the higest level to log everything. 
    Should be configure at compile time using compile time switch
 */
LOG_LEVEL_T g_loglevel = LOG_ALL;

static mqd_t loggertask_q;

mqd_t getHandle_LoggerTaskQueue()
{
    return loggertask_q;
}

FILE* logger_task_file_init(const char *logFileName)
{
    if(NULL == logFileName)
        return NULL;
    FILE *fp = fopen(logFileName,"r+");
    /* check if the file already exists then close it and save it as old_log */
    if(fp)
    {
        fclose(fp);
        char newFilename[40] = {0};
        snprintf(newFilename,sizeof(newFilename),"%u_%s",(unsigned)time(NULL),logFileName);
        int ret = rename(logFileName, newFilename);
        if(ret)
        {
            LOG_STDOUT(ERROR "Cannot backup old log file\n");
        }
    }
    fp = fopen(logFileName,"w+");
    if(NULL == fp)
    {
        LOG_STDOUT(INFO "Log file created\n");
    }
    return fp;
}

int logger_task_queue_init()
{
    struct mq_attr loggertaskQ_attr = {
        .mq_msgsize = sizeof(LOGGERTASKQ_MSG_T),
        .mq_maxmsg = 128,
        .mq_flags = 0,
        .mq_curmsgs = 0
    };

    mq_unlink(MQ_LOGGERTASK_NAME);
    loggertask_q = mq_open(MQ_LOGGERTASK_NAME, O_CREAT | O_RDWR, 0666, &loggertaskQ_attr);

    return loggertask_q;;
}

void logger_task_processMsg(FILE *fp)
{
    int ret,prio;
    LOGGERTASKQ_MSG_T queueData = {0};
    DEFINE_MAINTASK_STRUCT(maintaskRsp,MT_MSG_STATUS_RSP,LOGGER_TASK_ID);
    //struct timespec recv_timeout = {0};
    uint8_t continue_flag= 1;
    while(continue_flag)
    {
        memset(&queueData,0,sizeof(queueData));
        // clock_gettime(CLOCK_REALTIME, &recv_timeout);
        // recv_timeout.tv_sec += 3;
        // ret = mq_timedreceive(loggertask_q,(char*)&(queueData),sizeof(queueData),&prio, &recv_timeout);
        ret = mq_receive(loggertask_q,(char*)&(queueData),sizeof(queueData),&prio);
        // if(ERR == ret && ETIMEDOUT == errno)
        // {
        //     //LOG_STDOUT(ERROR "MQ_RECV TIMEOUT:%s\n",strerror(errno));
        //     continue;
        // }
        if(ERR == ret )
        {
            LOG_STDOUT(ERROR "MQ_RECV:%s\n",strerror(errno));
            continue;
        }
        switch(queueData.msgID)
        {
            case(LT_MSG_TASK_EXIT):
                continue_flag = 0;
                LT_LOG(fp,INFO "Logger Task Exit request from:%s\n",getTaskIdentfierString(queueData.sourceID));
                LOG_STDOUT(INFO "Logger Task Exit request from:%s\n",getTaskIdentfierString(queueData.sourceID));
                break;
            case(LT_MSG_LOG):
                if(g_loglevel >= queueData.loglevel)
                {
                    #ifdef STDOUT_LOG
                    LOG_STDOUT(INFO "[%s] Sender:%s\tMsg:%s",queueData.timestamp,getTaskIdentfierString(queueData.sourceID),queueData.msgData);
                    #endif
                    LT_LOG(fp,INFO "[%s] Sender:%s\tMsg:%s",queueData.timestamp,getTaskIdentfierString(queueData.sourceID),queueData.msgData);
                }
                break;
            case(LT_MSG_TASK_STATUS):
                if(MAIN_TASK_ID == queueData.sourceID)
                {
                    /* Send back task alive response to main task */
                    LT_LOG(fp,INFO "[%s] Sender:%s\tMsg:%s",queueData.timestamp,getTaskIdentfierString(queueData.sourceID),queueData.msgData);
                    POST_MESSAGE_MAINTASK(&maintaskRsp, "Logger Alive");
                }
                break;

            default:
            LOG_STDOUT(INFO "INVALID QUEUE LOG ID\n");
                break;
        }
    }

}

void* logger_task_callback(void *threadparam)
{
    LOG_STDOUT(INFO "LOGGER TASK STARTED\n");

    char *filename = configdata_getLogpath();
    FILE *fp;
    if(filename)
    {
        fp = logger_task_file_init(filename);
    }
    else
    {
        LOG_STDOUT(WARNING "No filename found from config file\n");
        fp = logger_task_file_init("project1.log");
    }
    
    if(NULL == fp)
    {
        LOG_STDOUT(ERROR "LOGGER TASK LOG FILE INIT FAIL\n");
        exit(ERR);
    }

    int ret = logger_task_queue_init();
    if(ERR == ret)
    {
        LOG_STDOUT(ERROR "LOGGER TASK INIT%s\n",strerror(errno));
        exit(ERR);
    }

    LOG_STDOUT(INFO "LOGGER TASK INIT COMPLETED\n");
    LT_LOG(fp,INFO "LOGGER TASK INIT COMPLETED\n");
    pthread_barrier_wait(&tasks_barrier);

    #ifdef VALUES
    LOG_STDOUT(INFO "LOGGER TASK UP and RUNNING\n");
    #endif
    #ifdef LOGVALUES
    LT_LOG(fp,INFO "LOGGER TASK UP and RUNNING\n");
    #endif
    /* Process Log queue msg which executes untill the log_task_end flag is set to true*/
    logger_task_processMsg(fp);

    mq_close(loggertask_q);
    fflush(fp);
    fclose(fp);
    LOG_STDOUT(INFO "Logger Task Exit.\n");
    return (void*)SUCCESS;
}/**
 * @brief 
 * 
 * @file readConfiguration.c
 * @author Gunj Manseta
 * @date 2018-03-17
 */


#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>

#include "readConfiguration.h"

#define CONFIG_DATA_NUM 3

#define CONFIG_FILE "configuration.dat"

typedef enum
{
    LOG_PATH_STRING,
    TASK_SETUP_TIME_SEC_UINT8,
    TASK_ALIVE_TIMEOUT_SEC_UINT8
}CONFIG_DATA_INDEX;

static void* configurationData[CONFIG_DATA_NUM] = {0};

char* configdata_getLogpath()
{
    return ((char*)configurationData[LOG_PATH_STRING]);
}

uint32_t configdata_getSetupTime()
{
    return (*((uint32_t*)configurationData[TASK_SETUP_TIME_SEC_UINT8]));
}
uint32_t configdata_getAliveTimeout()
{
    return (*((uint32_t*)configurationData[TASK_ALIVE_TIMEOUT_SEC_UINT8]));
}

int configdata_setup()
{
    FILE *fp;
    fp = fopen(CONFIG_FILE, "r");
    if(NULL ==fp)
        return -1;
    
    configurationData[LOG_PATH_STRING] = (char*)malloc(sizeof(char)*20);
    configurationData[TASK_SETUP_TIME_SEC_UINT8] = (uint32_t*)malloc(sizeof(uint32_t));
    configurationData[TASK_ALIVE_TIMEOUT_SEC_UINT8] = (uint32_t*)malloc(sizeof(uint32_t));

    size_t readBytes = fscanf(fp,"%s %u %u",(char*)configurationData[LOG_PATH_STRING],(uint32_t*)configurationData[TASK_SETUP_TIME_SEC_UINT8], (uint32_t*)configurationData[TASK_ALIVE_TIMEOUT_SEC_UINT8]);
    
    #ifdef SELF_TEST
    printf("PATH: %s\n",(char*)configurationData[LOG_PATH_STRING]);
    printf("SETUP: %u\n",*(uint32_t*)configurationData[TASK_SETUP_TIME_SEC_UINT8]);
    printf("TO: %u\n",*(uint32_t*)configurationData[TASK_ALIVE_TIMEOUT_SEC_UINT8]);
    #endif

    return 0;
}

void configdata_flush()
{
    for(int i = 0; i <CONFIG_DATA_NUM ; i ++)
    {
        free(configurationData[i]);
        configurationData[i] = NULL;
    }
}

#ifdef SELF_TEST
int main()
{
    int ret = configdata_setup();
    if(ret) return ret;

    printf("From func: %s\n",configdata_getLogpath());
    printf("From func: %u\n",configdata_getSetupTime());
    printf("From func: %u\n",configdata_getAliveTimeout());

    configdata_flush();
    return 0;
}
#endif/**
 * @brief 
 * 
 * @file common_helper.c
 * @author Gunj Manseta
 * @date 2018-03-10
 */

#include "common_helper.h"
#include "main_task.h"
#include "logger_task.h"
#include "light_sensor_task.h"
#include "temperature_sensor_task.h"
#include "posixTimer.h"


const char* const task_identifier_string[NUM_CHILD_THREADS+1] =
{
    (const char*)"Logger Task",
    (const char*)"Temperature Task",    
    (const char*)"Socket Task",
    (const char*)"Light Task",
    (const char*)"Main Task",

};

mqd_t get_queue_handle(TASK_IDENTIFIER_T taskid)
{
    mqd_t queueHandle;
    switch(taskid)
    {
        case(MAIN_TASK_ID):
            queueHandle = getHandle_MainTaskQueue();
            break;
        case(LOGGER_TASK_ID):
            queueHandle = getHandle_LoggerTaskQueue();
            break;
        case(LIGHT_TASK_ID):
            queueHandle = getHandle_LightTaskQueue();
            break;
        case(TEMPERATURE_TASK_ID):
            queueHandle = getHandle_TemperatureTaskQueue();
            break;
        // case(SOCKET_TASK_ID):
        //     queueHandle = getHandle_SocketTaskQueue();
        //     break;
        default:
            queueHandle = 0;
            break;
    }

    return queueHandle;

}

int register_and_start_timer(timer_t *timer_id, uint32_t usec, uint8_t oneshot, void (*timer_handler)(union sigval), void *handlerArgs)
{
    if(register_timer(timer_id, timer_handler, timer_id) == -1)
	{
	    LOG_STDOUT("[ERROR] Register Timer\n");
		return ERR;
	}
	// else
	// 	LOG_STDOUT("[INFO] Timer created\n");
	
	if(start_timer(*timer_id , usec, oneshot) == -1)
	{
		LOG_STDOUT("[ERROR] Start Timer\n");
		return ERR;
	}
	// else
	// 	LOG_STDOUT("[INFO] Timer started\n");

}/**
 * @brief 
 * 
 * @file light_sensor_task.c
 * @author Gunj Manseta
 * @date 2018-03-11
 */

#include <pthread.h>
#include <fcntl.h>           /* For O_* constants */
#include <sys/stat.h>        /* For mode constants */
#include <mqueue.h>
#include <string.h>
#include <errno.h>

#include "main_task.h"
#include "logger_task.h"
#include "light_sensor_task.h"
#include "error_data.h"
#include "apds9301_sensor.h"
#include "my_i2c.h"
#include "common_helper.h"


#define MQ_LIGHTTASK_NAME "/lighttask_queue"

#define LUX_THRESHOLD (50)

static mqd_t lighttask_q;

pthread_mutex_t stateChangeLock;

volatile static DAY_STATE_T isDay;


DAY_STATE_T getLightTask_state()
{
    DAY_STATE_T state;
    pthread_mutex_lock(&stateChangeLock);
    state = isDay;
    pthread_mutex_unlock(&stateChangeLock);
    return state;
}

float getLightTask_lux()
{
    float lux = APDS9301_getLux();
    return lux;
}

static void timer_handler_getAndUpdateState(union sigval sig)
{
    DAY_STATE_T state;

    DEFINE_LOG_STRUCT(logtaskstruct,LT_MSG_LOG,LIGHT_TASK_ID);

    float lux = APDS9301_getLux();
    if(lux < 0) 
    {
        LOG_STDOUT(ERROR "Light sensor inactive\n");
        POST_MESSAGE_LOGTASK(&logtaskstruct,ERROR "Light sensor inactive\n");
        return;
    }
    else 
    {
        #ifdef VALUES
        LOG_STDOUT(INFO "Lux: %.03f\n",lux);
        #endif

        #ifdef LOGVALUES
        POST_MESSAGE_LOGTASK(&logtaskstruct,INFO "Lux: %.03f\n",lux);
        #endif
    }

    (lux < LUX_THRESHOLD) ? (state = NIGHT) : (state = DAY);
    #ifdef VALUES
    LOG_STDOUT(INFO "State: %s\n", ((state == DAY)?"DAY":"NIGHT"));
    #endif
    
    pthread_mutex_lock(&stateChangeLock);
    isDay = state;
    pthread_mutex_unlock(&stateChangeLock);
}

mqd_t getHandle_LightTaskQueue()
{
    return lighttask_q;
}

/**
 * @brief 
 * 
 * @return int 
 */
int light_task_queue_init()
{
    struct mq_attr lighttaskQ_attr = {
        .mq_msgsize = sizeof(LIGHTTASKQ_MSG_T),
        .mq_maxmsg = 128,
        .mq_flags = 0,
        .mq_curmsgs = 0
    };

    mq_unlink(MQ_LIGHTTASK_NAME);
    lighttask_q = mq_open(MQ_LIGHTTASK_NAME, O_CREAT | O_RDWR, 0666, &lighttaskQ_attr);

    return lighttask_q;;
}

void light_task_processMsg()
{
    int ret,prio;
    LIGHTTASKQ_MSG_T queueData = {0};
    DEFINE_MAINTASK_STRUCT(maintaskRsp,MT_MSG_STATUS_RSP,LIGHT_TASK_ID);
    DEFINE_LOG_STRUCT(logtaskstruct,LT_MSG_LOG,LIGHT_TASK_ID);
    //struct timespec recv_timeout = {0};
    uint8_t continue_flag = 1;
    /* Uncomment to check the keep alive feature. Only a cancellable function defined by POSIX can be used below as the we are using pthread_cancel */
    //sleep(10);
    while(continue_flag)
    {
        memset(&queueData,0,sizeof(queueData));
        //clock_gettime(CLOCK_REALTIME, &recv_timeout);
        //recv_timeout.tv_sec += 3;
        //ret = mq_timedreceive(lighttask_q,(char*)&(queueData),sizeof(queueData),&prio, &recv_timeout);
        ret = mq_receive(lighttask_q,(char*)&(queueData),sizeof(queueData),&prio);
        if(ERR == ret)
        {
            LOG_STDOUT(ERROR "MQ_RECV:%s\n",strerror(errno));
            continue;
        }
        switch(queueData.msgID)
        {
            case(LIGHT_MSG_TASK_STATUS):
                /* Send back task alive response to main task */
                POST_MESSAGE_LOGTASK(&logtaskstruct,INFO "ALIVE STATUS by:%s\n",getTaskIdentfierString(queueData.sourceID));
                POST_MESSAGE_MAINTASK(&maintaskRsp, "Light sensor task Alive");
                break;
            case(LIGHT_MSG_TASK_GET_STATE):

                // (queueData.packet.reg_value != NULL)? (*queueData.packet.reg_value = getLightTask_state()) : 0;
                // queueData.packet.buffLen = 1;
                // (queueData.packet.is_sync) ? (sem_post(queueData.packet.sync_semaphore)): 0;
                
                break;
            case(LIGHT_MSG_TASK_READ_DATA):
                break;
            case(LIGHT_MSG_TASK_WRITE_CMD):
                break;
            case(LIGHT_MSG_TASK_POWERDOWN):
                APDS9301_powerdown();
                break;
            case(LIGHT_MSG_TASK_POWERUP):
                APDS9301_poweron();
                break;
            case(LIGHT_MSG_TASK_EXIT):
                continue_flag = 0;
                LOG_STDOUT(INFO "Light Task Exit request from:%s\n",getTaskIdentfierString(queueData.sourceID));
                POST_MESSAGE_LOGTASK(&logtaskstruct,INFO "Light Task Exit request from:%s\n",getTaskIdentfierString(queueData.sourceID));
                break;
            default:
                break;
        }
    }

}

int light_task_sensorUP(I2C_MASTER_HANDLE_T *i2c)
{
    int ret = 0;
    ret = I2Cmaster_Init(i2c);
    if(ret !=0)
    {
        printErrorCode(ret);
        LOG_STDOUT(ERROR "I2C Master init failed\n"); 
    }

    ret = APDS9301_poweron();
    if(ret == 0) LOG_STDOUT(INFO "[OK] Sensor powered ON\n");

    ret = APDS9301_test();
    if(ret == 0) {LOG_STDOUT(INFO "[OK] Sensor Test\n");}
    else {LOG_STDOUT(INFO "[FAIL] Sensor Test\n");}

    return ret;
}

int light_task_sensorDOWN(I2C_MASTER_HANDLE_T *i2c)
{
    int ret = 0;
    ret = APDS9301_powerdown();
    if(ret == 0) LOG_STDOUT(INFO "Sensor powered DOWN\n");
    ret = I2Cmaster_Destroy(i2c);
    if(ret != 0)
    {
        printErrorCode(ret);
        LOG_STDOUT(WARNING "I2C Master destroy failed\n"); 
    }

    return ret;
}

void* light_task_callback(void *threadparam)
{
    LOG_STDOUT(INFO "LIGHT TASK STARTED\n");

    int ret = light_task_queue_init();
    if(ERR == ret)
    {
        LOG_STDOUT(ERROR "LIGHT TASK QUEUE INIT:%s\n",strerror(errno));
        exit(ERR);
    }

    I2C_MASTER_HANDLE_T i2c;
    ret = light_task_sensorUP(&i2c);
    if(ERR == ret)
    {
        LOG_STDOUT(ERROR "LIGHT TASK SENSOR INIT:%s\n",strerror(errno));
        goto FAIL_EXIT_SENSOR;
    }

    
    LOG_STDOUT(INFO "[OK] LIGHT TASK INIT COMPLETED\n");
    pthread_barrier_wait(&tasks_barrier);

    /* Registering a timer for 2 sec to update the state of the snesor value by getting the lux value from the sensor*/
    timer_t timer_id;
    if(ERR == register_and_start_timer(&timer_id, 2*MICROSEC, 0, timer_handler_getAndUpdateState, &timer_id))
    {
        // LOG_STDOUT(ERROR "Timer Error\n");
        goto FAIL_EXIT;
    }

    /* Process Log queue msg which executes untill the log_task_end flag is set to true*/
    light_task_processMsg();

    ret = delete_timer(timer_id);
    if(ERR == ret)
    {
        LOG_STDOUT(ERROR "LIGHT TASK DELETE TIMER:%s\n",strerror(errno));
    }

FAIL_EXIT:

    light_task_sensorDOWN(&i2c);

FAIL_EXIT_SENSOR:
    mq_close(lighttask_q);
    LOG_STDOUT(INFO "Light task exit.\n");
    return SUCCESS;
}
#include "posixTimer.h"

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/types.h>
#include <string.h>

int register_timer(timer_t *timer_id, void (*timer_handler)(union sigval), void *handlerArgs)
{

	if(NULL == timer_id)
		return -1;
		
	struct sigevent sige;

	/*SIGEV_THREAD will call the handler as if it was a new thread */
	sige.sigev_notify = SIGEV_THREAD;
	sige.sigev_notify_function = timer_handler;
//	sige.sigev_value.sival_ptr = timer_id;
	sige.sigev_value.sival_ptr = handlerArgs;
	sige.sigev_notify_attributes = NULL;

	int ret = timer_create(CLOCK_REALTIME, &sige, timer_id);
	
	return ret;
}

int start_timer(timer_t timer_id , uint64_t time_usec, uint8_t oneshot)
{
	// if(NULL == timer_id)
	// 	return -1;
		
	struct itimerspec ts;
	
	ts.it_value.tv_sec = time_usec / MICROSEC;
	ts.it_value.tv_nsec = (time_usec % MICROSEC) * 1000;
	if(1 == oneshot)
	{
		ts.it_interval.tv_sec = 0;
		ts.it_interval.tv_nsec = 0;
	}
	else
	{
		ts.it_interval.tv_sec = ts.it_value.tv_sec;
		ts.it_interval.tv_nsec = ts.it_value.tv_nsec;
	}

	int ret = timer_settime(timer_id, 0, &ts, 0);
	
	return ret;
}

int stop_timer(timer_t timer_id)
{
	// if(NULL == timer_id)
	// 	return -1;
		
	struct itimerspec ts;
	
	ts.it_value.tv_sec = 0;
	ts.it_value.tv_nsec = 0;
	ts.it_interval.tv_sec = 0;
	ts.it_interval.tv_nsec = 0;

	int ret = timer_settime(timer_id, 0, &ts, 0);
	
	return ret;
}


int delete_timer(timer_t timer_id)
{
	// if(NULL == timer_id)
	// 	return -1;
	
	int ret = timer_delete(timer_id);

	return ret;


}
/**
 * @brief 
 * 
 * @file apds9301_sensor.c
 * @author Gunj Manseta
 * @date 2018-03-14
 */

#include <math.h>
#include "apds9301_sensor.h"
#include"my_i2c.h"
#include "error_data.h"
#include <string.h>

#define APDS9301_SENSOR_ID (0x50)

int APDS9301_test()
{
    uint8_t data;
    int ret = APDS9301_readID(&data);
    if(ret == 0) 
    {
        (APDS9301_SENSOR_ID == (data & 0xF0)) ? 0 : (ret = -1);
    }

    return ret; 
    
}

int APDS9301_write_ThLow(uint16_t thlow)
{
    int ret = I2Cmaster_write_word(APDS9301_SLAVE_ADDR, APDS9301_INT_TH_LL_REG | APDS9301_CMD_WORD_EN, thlow, 0);
    return ret;
}

int APDS9301_write_ThHigh(uint16_t thhigh)
{
    int ret = I2Cmaster_write_word(APDS9301_SLAVE_ADDR, APDS9301_INT_TH_HL_REG | APDS9301_CMD_WORD_EN , thhigh, 0);
    return ret;
}

int APDS9301_read_ThLow(uint16_t *thlow)
{
    int ret = I2Cmaster_read_bytes(APDS9301_SLAVE_ADDR, APDS9301_INT_TH_LL_REG, (uint8_t*)thlow, sizeof(thlow));
    return ret;
}

int APDS9301_read_ThHigh(uint16_t *thhigh)
{
    int ret = I2Cmaster_read_bytes(APDS9301_SLAVE_ADDR, APDS9301_INT_TH_HL_REG, (uint8_t*)thhigh, sizeof(thhigh));
    return ret;
}

int APDS9301_readControlReg(uint8_t *ctrl_reg)
{
    int ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_CTRL_REG, ctrl_reg);
    return ret;
}

int APDS9301_mode_highGain()
{
    uint8_t data;
    int ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_TIMING_REG, &data);
    if(ret != 0)
        return ret;

    data |= (uint8_t)APDS9301_TIMING_GAIN;

    ret = I2Cmaster_write_byte(APDS9301_SLAVE_ADDR, APDS9301_TIMING_REG, data);

    return ret;
}
int APDS9301_mode_lowGain_default()
{
    uint8_t data;
    int ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_TIMING_REG, &data);
    if(ret != 0)
        return ret;

    data &= ~(uint8_t)APDS9301_TIMING_GAIN;

    ret = I2Cmaster_write_byte(APDS9301_SLAVE_ADDR, APDS9301_TIMING_REG, data);

    return ret;

}

int APDS9301_mode_interrupt(uint8_t enable)
{
    uint8_t data;
    int ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_INT_CTRL_REG, &data);
    if(ret != 0)
        return ret;

    if(enable)
        data |= (uint8_t)APDS9301_INTCTRL_IEN;
    else
        data &= ~(uint8_t)APDS9301_INTCTRL_IEN;

    ret = I2Cmaster_write_byte(APDS9301_SLAVE_ADDR, APDS9301_INT_CTRL_REG, data);

    return ret;
}
int APDS9301_clearPendingInterrupt()
{
    int ret = I2Cmaster_write(APDS9301_SLAVE_ADDR, APDS9301_CMD_REG | APDS9301_CMD_INT_CLEAR);
    return ret;    
}

int APDS9301_mode_manualcontrol(uint8_t on)
{
    uint8_t data;
    int ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_TIMING_REG, &data);
    if(ret != 0)
        return ret;

    data &= ~(uint8_t)APDS9301_TIMING_MANUAL(1);
    data |= (uint8_t)APDS9301_TIMING_MANUAL(on);

    ret = I2Cmaster_write_byte(APDS9301_SLAVE_ADDR, APDS9301_TIMING_REG, data);

    return ret;
}

int APDS9301_mode_integrationTime(uint8_t x)
{
    uint8_t data;
    int ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_TIMING_REG, &data);
    if(ret != 0)
        return ret;
    
    data &= ~(uint8_t)APDS9301_TIMING_INTEG(3);
    data |= (uint8_t)APDS9301_TIMING_INTEG(x);

    ret = I2Cmaster_write_byte(APDS9301_SLAVE_ADDR, APDS9301_TIMING_REG, data);

    return ret;
}


int APDS9301_poweron()
{
    int ret = I2Cmaster_write_byte(APDS9301_SLAVE_ADDR, APDS9301_CTRL_REG, APDS9301_CTRL_POWERON);
    return ret;
}
int APDS9301_powerdown()
{
    int ret = I2Cmaster_write_byte(APDS9301_SLAVE_ADDR, APDS9301_CTRL_REG, APDS9301_CTRL_POWEROFF);
    return ret;
}
int APDS9301_readID(uint8_t *id)
{
    int ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_ID_REG, id);
    return ret;
}

int APDS9301_readCh0(uint16_t *ch0_data)
{
    int ret;
    uint8_t ch0_data_L, ch0_data_H;
    ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_CH0_DATALOW, &ch0_data_L);
    if(ret)
        return ret;

    ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_CH0_DATAHIGH, &ch0_data_H);

    if(!ret)
        *ch0_data = (ch0_data_H << 8) | ch0_data_L ;
    
    return ret;
}

int APDS9301_readCh1(uint16_t *ch1_data)
{
    int ret;
    uint8_t ch1_data_L, ch1_data_H;
    ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_CH1_DATALOW, &ch1_data_L);
    if(ret)
        return ret;

    ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, APDS9301_CH1_DATAHIGH, &ch1_data_H);
    
    if(!ret)
        *ch1_data = (ch1_data_H << 8) | ch1_data_L;
    
    return ret;

}

float APDS9301_getLux()
{
    float ratio, lux = -1;
    uint16_t Ch0, Ch1;

    int ret  = APDS9301_readCh0(&Ch0);
    if(ret)
        return lux;

    ret  = APDS9301_readCh1(&Ch1);
    if(ret)
        return lux;

    if(Ch0 != 0)
        ratio = (float)Ch1/(float)Ch0;
    else
        ratio = 0;

    //Calculate LUX - calculations are referred from the Sensor datasheet
	if (ratio > 0 && ratio <= 0.50)
	{
		lux = 0.0304*Ch0 - 0.062*Ch0*(pow(ratio, 1.4));
	}
	else if (ratio > 0.50 && ratio <= 0.61)
	{
		lux = 0.0224*Ch0 - 0.031*Ch1;
	}
	else if (ratio > 0.61 && ratio <= 0.80)
	{
		lux = 0.0128*Ch0 - 0.0153*Ch1;
	}
	else if (ratio > 0.80 && ratio <= 1.30)
	{
		lux = 0.00146*Ch0 - 0.00112*Ch1;
	}
	else if (ratio > 1.30)
	{
		lux = 0;
    }

    return lux;
}


uint8_t* APDS9301_memDump()
{
    uint8_t *memdump = (uint8_t*)malloc(15*sizeof(uint8_t));
    memset(memdump, 0 , 15);

    for(uint8_t i = 0 ; i < 0x10; i++)
    {
        if(i == 0x7 ||  i == 0x9 || i == 0xB)
            continue;
        
        int ret = I2Cmaster_read_byte(APDS9301_SLAVE_ADDR, i | APDS9301_CMD_REG, memdump+i);
        if(ret != 0 ) continue;
    }

    return memdump;
}

int APDS9301__setmode_allDefault()
{
    int ret = APDS9301_mode_lowGain_default();
    if(ret) return ret;
    ret = APDS9301_mode_integrationTime2_default();
    if(ret) return ret;
    ret = APDS9301_mode_interruptDisable_default();
    if(ret) return ret;
    ret = APDS9301_mode_manualcontrolOFF_default();
    return ret;
}/**
 * @brief 
 * 
 * @file socket_task.c
 * @author Gunj Manseta
 * @date 2018-03-09
 */

#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <errno.h>
#include <arpa/inet.h>
		
#include "socket_task.h"
#include "logger_task.h"
#include "main_task.h"
#include "error_data.h"
#include "common_helper.h"
#include "sensor_common_object.h"
#include "light_sensor_task.h"
#include "temperature_sensor_task.h"

#define SERVER_PORT 	3000
#define SERVER_IP       "127.0.0.1"
#define MAX_CONNECTIONS 5

sig_atomic_t socketTask_continue = 1;

/**
 * @brief 
 * 
 * @param req_in 
 * @return REMOTE_RESPONSE_T 
 */
REMOTE_RESPONSE_T processRemoteRequest(REMOTE_REQUEST_T req_in);

/**
 * @brief 
 * 
 * @param sigval 
 */
static void timer_handler_sendSTAliveMSG(union sigval sig)
{		
    pthread_mutex_lock(&aliveState_lock);
	aliveStatus[SOCKET_TASK_ID]++;
	pthread_mutex_unlock(&aliveState_lock);
}

/**
 * @brief 
 * 
 * @param server_socket 
 * @return int 
 */
int socket_task_init(int server_socket)
{
    int option = 1;
	struct sockaddr_in addr;
	
	if((server_socket = socket(AF_INET,SOCK_STREAM,0)) == 0)
	{
		LOG_STDOUT(ERROR "Socket Creation:%s\n",strerror(errno));
		return ERR;
	}

	LOG_STDOUT(INFO "Socket Created\n");

	if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEPORT | SO_REUSEADDR, &(option), sizeof(option)))
    {
        LOG_STDOUT(ERROR "Cannot Set socket options:%s\n",strerror(errno));
        return ERR;
    }
	/*Setting up the sockaddr_in structure */
	addr.sin_family = AF_INET;
	//addr.sin_addr.s_addr = inet_addr(SERVER_IP);	
	addr.sin_addr.s_addr = INADDR_ANY;	//Using local loopback	
	addr.sin_port = htons(SERVER_PORT);

	if((bind(server_socket,(struct sockaddr*)&addr, sizeof(addr))) < 0)
	{
		LOG_STDOUT(ERROR "Cannot bind the socket:%s\n",strerror(errno));
		return ERR;
	}

	LOG_STDOUT(INFO "Socket binded\n");

    if(listen(server_socket,MAX_CONNECTIONS) < 0)
	{
		LOG_STDOUT(ERROR "Cannot listen:%s\n",strerror(errno));
		return ERR;
	}

    LOG_STDOUT(INFO "Socket started listening on IP:%s PORT:%d\n",SERVER_IP,SERVER_PORT);

    return server_socket;
}

void* socket_task_callback(void* threadparam)
{
    int server_socket,accepted_socket, option = 1;
    struct sockaddr_in peer_addr;
	int addrLen = sizeof(peer_addr);
    LOG_STDOUT(INFO "SOCKET TASK STARTED\n");

    server_socket  = socket_task_init(server_socket);
    if(ERR == server_socket)
    {
        LOG_STDOUT(ERROR "Socket task init failed.\n");
        exit(ERR);
    }


	LOG_STDOUT(INFO "SOCKET TASK INIT COMPLETED\n");
	pthread_barrier_wait(&tasks_barrier);

	DEFINE_LOG_STRUCT(logData,LT_MSG_LOG,SOCKET_TASK_ID);

	while(socketTask_continue)
	{
		POST_MESSAGE_LOGTASK(&logData,"Accepting connections...\n");
		accepted_socket = accept(server_socket, (struct sockaddr*)&peer_addr,(socklen_t*)&addrLen);
		if(accepted_socket < 0)
		{
			LOG_STDOUT(ERROR "Cannot accept:%s\n",strerror(errno));
			POST_MESSAGE_LOGTASK(&logData,ERROR "Cannot accept:%s\n",strerror(errno));
			continue;
		}

		char peer_IP[20] = {0};
		POST_MESSAGE_LOGTASK(&logData,INFO "Conn accepted. Peer Add: %s\n",inet_ntop(AF_INET, &peer_addr.sin_addr, peer_IP, sizeof(peer_IP)));
		LOG_STDOUT(INFO "Connection accepted from peer Addr: %s\n",inet_ntop(AF_INET, &peer_addr.sin_addr, peer_IP, sizeof(peer_IP)));

		while(socketTask_continue)
		{
			REMOTE_REQUEST_T req_in = {0};
			REMOTE_RESPONSE_T rsp_out = {0};
			int nbytes = 0;
			do{
				nbytes = recv(accepted_socket, (((char*)&(req_in))+nbytes), sizeof(req_in), 0);
			}while(nbytes < sizeof(req_in) && nbytes != -1);

			LOG_STDOUT(INFO "--CLIENT REQUEST: bytes:%d ID:%d\n",nbytes,req_in.request_id);
			POST_MESSAGE_LOGTASK(&logData,INFO "--CLIENT REQUEST: bytes:%d ID:%d\n",nbytes,req_in.request_id);
			rsp_out = processRemoteRequest(req_in);
			
			if(rsp_out.rsp_id == CONN_CLOSE_RSP) 
				{break;}
			if(rsp_out.rsp_id == CONN_KILL_APP_RSP) 
				{/* socketTask_continue = 0; */ break;}
		
			nbytes = send(accepted_socket , (char*)&rsp_out , sizeof(rsp_out), 0 );
			if(nbytes < sizeof(rsp_out))
			{
				LOG_STDOUT(ERROR "Cannot send complete data\n");
				POST_MESSAGE_LOGTASK(&logData,ERROR "Cannot send complete data\n");
				break;
			}

			LOG_STDOUT(INFO "Number of bytes sent: %d\n",nbytes);
			POST_MESSAGE_LOGTASK(&logData,INFO "Number of bytes sent: %d\n",nbytes);
		}

        /* Create a new thread to handle the connection and go back to accepting */
        close(accepted_socket);
		LOG_STDOUT(INFO "Socket Closed\n");
		POST_MESSAGE_LOGTASK(&logData,INFO "Socket Closed\n");
        /* Think of a mechanism to close this socket task as there is a while(1) loop */

    }

	// signal(SIGUSR1, signal_handler);

}

REMOTE_RESPONSE_T processRemoteRequest(REMOTE_REQUEST_T req_in)
{
	REMOTE_RESPONSE_T rsp_out = {0};
	switch(req_in.request_id)
    {
        case(GET_FUNC):
			rsp_out.rsp_id=GET_FUNC;
            strncpy(rsp_out.metadata,"GET_TEMP DAY_NIGHT\n", sizeof(rsp_out.metadata));
            break;
        case(GET_TEMP_C):
			rsp_out.rsp_id=GET_TEMP_C;
			rsp_out.data.floatingData = getTempTask_temperature();
            LOG_STDOUT(INFO "REMOTE REQUEST GET_TEMP_C:.03%f\n",rsp_out.data.floatingData);
            break;
        case(GET_TEMP_F):
			rsp_out.rsp_id=GET_TEMP_F;
			rsp_out.data.floatingData = getTempTask_temperature();
			rsp_out.data.floatingData = (rsp_out.data.floatingData * 1.8) + 32;
            LOG_STDOUT(INFO "REMOTE REQUEST GET_TEMP_F:%.03f\n",rsp_out.data.floatingData);
            break;
        case(GET_TEMP_K):
			rsp_out.rsp_id=GET_TEMP_K;
			rsp_out.data.floatingData = getTempTask_temperature() + 273.15;
            LOG_STDOUT(INFO "REMOTE REQUEST GET_TEMP_K:%.03f\n",rsp_out.data.floatingData);
            break;
        case(GET_LUX):
			rsp_out.rsp_id=GET_LUX;
			rsp_out.data.floatingData = getLightTask_lux();
            LOG_STDOUT(INFO "REMOTE REQUEST GET_LUX:%.03f\n",rsp_out.data.floatingData);
            break;
        case(GET_DAY_NIGHT):
			rsp_out.rsp_id=GET_DAY_NIGHT;
			rsp_out.data.isNight = getLightTask_state();
            LOG_STDOUT(INFO "REMOTE REQUEST GET_DAY_NIGHT\n");
            break;
    	case(CONN_CLOSE_REQ):
			rsp_out.rsp_id=CONN_CLOSE_RSP;
			LOG_STDOUT(INFO "REMOTE REQUEST CLOSE CONNECTION\n");
             break;
		case(CONN_KILL_APP_REQ):
			rsp_out.rsp_id=CONN_KILL_APP_RSP;
			LOG_STDOUT(INFO "REMOTE REQUEST KILL APP\n");
             break;
        default:
			LOG_STDOUT(INFO "REMOTE REQUEST INVALID\n");
            break;

    }
	return rsp_out;
}/**
 * @brief 
 * 
 * @file my_i2c.c
 * @author Gunj Manseta
 * @date 2018-03-13
 */

#include <errno.h>
#include <string.h>
#include "my_i2c.h"


static I2C_MASTER_HANDLE_T *internal_master_handle = NULL;
static pthread_mutex_t init_destroy_lock = PTHREAD_MUTEX_INITIALIZER;

void printErrorCode(int errorCode)
{
    //#define VERBOSE
    #ifdef VERBOSE
    mraa_result_print(errorCode);
    #endif
}

int I2Cmaster_Init(I2C_MASTER_HANDLE_T *handle)
{
    int ret = 0;
    if(pthread_mutex_lock(&init_destroy_lock))
        return -1;
    if(NULL != internal_master_handle)
    {
        handle = internal_master_handle;
        ret =  0;
    }
    else if(handle)
    {
        handle->i2c_context = mraa_i2c_init_raw(BB_I2C_BUS_2);
        /* internal i2c context failed to init */
        if(NULL == handle->i2c_context)
        {
            internal_master_handle = NULL;
            ret = -1;
        }
        /* If spinlock init fails */
        else if( -1 == pthread_spin_init(&handle->handle_lock, PTHREAD_PROCESS_PRIVATE))
        {
            internal_master_handle = NULL;
            mraa_i2c_stop(handle->i2c_context);
            ret = -1;
        }
        /* Everyting goes as expected */
        else
        {
            internal_master_handle = handle;
            ret = 0;
        }
    }
    /* If handle is null */
    else
        ret = -1;

    if(pthread_mutex_unlock(&init_destroy_lock))
        return -1;

    return ret;
}

int I2Cmaster_Destroy(I2C_MASTER_HANDLE_T *handle)
{
    int ret;
    if(pthread_mutex_lock(&init_destroy_lock))
        return -1;

    /* If the input handle is not null and the input initialized handle should match the internal handle */    
    if(NULL != handle && internal_master_handle == handle && NULL != internal_master_handle)
    {
        ret = mraa_i2c_stop(handle->i2c_context);
        if(ret == 0)
        {
            static int timeout = 5000;
            do{
                ret = pthread_spin_destroy(&handle->handle_lock);
                timeout--;
            }while(EBUSY == ret && timeout > 0);

            if(ret == 0)
            {
                internal_master_handle = NULL;
            }
        }
    }
    else if(NULL == internal_master_handle)
    {
        ret = 0;
    }
    else 
    {
        ret = -1;
    }

    if(pthread_mutex_unlock(&init_destroy_lock))
        return -1;

    return ret;
} 

I2C_MASTER_HANDLE_T* getMasterI2C_handle()
{
    return internal_master_handle;
}

int I2Cmaster_write_byte(uint8_t slave_addr, uint8_t reg_addr, uint8_t data)
{
    if(NULL == internal_master_handle)
    {
        return -1;
    }

    pthread_spin_lock(&internal_master_handle->handle_lock);

    mraa_result_t ret =  mraa_i2c_address(internal_master_handle->i2c_context, slave_addr);
    if(0 == ret)
    {   
        ret = mraa_i2c_write_byte_data(internal_master_handle->i2c_context, data, reg_addr);
    }

    pthread_spin_unlock(&internal_master_handle->handle_lock);

    return ret;
}

int I2Cmaster_write(uint8_t slave_addr, uint8_t reg_addr)
{
    if(NULL == internal_master_handle)
    {
        return -1;
    }

    pthread_spin_lock(&internal_master_handle->handle_lock);

    mraa_result_t ret =  mraa_i2c_address(internal_master_handle->i2c_context, slave_addr);
    if(0 == ret)
    {   
        ret = mraa_i2c_write_byte(internal_master_handle->i2c_context, reg_addr);
    }

    pthread_spin_unlock(&internal_master_handle->handle_lock);

    return ret;
}


int I2Cmaster_write_word(uint8_t slave_addr, uint8_t reg_addr, uint16_t data, uint8_t lsb_first)
{
    if(NULL == internal_master_handle)
    {
        return -1;
    }
    
    if(lsb_first)
    {
        data = ( ((data & 0xF0)>>4)| ((data &0x0F)<<4) ); 
    }

    pthread_spin_lock(&internal_master_handle->handle_lock);

    mraa_result_t ret =  mraa_i2c_address(internal_master_handle->i2c_context, slave_addr);
    if(0 == ret)
    {   
        ret = mraa_i2c_write_word_data(internal_master_handle->i2c_context, data, reg_addr);
    }

    pthread_spin_unlock(&internal_master_handle->handle_lock);

    return ret;

}


int I2Cmaster_read_byte(uint8_t slave_addr, uint8_t reg_addr, uint8_t *data)
{
    if(NULL == internal_master_handle)
    {
        return -1;
    }

    pthread_spin_lock(&internal_master_handle->handle_lock);

    mraa_result_t ret =  mraa_i2c_address(internal_master_handle->i2c_context, slave_addr);
    if(0 == ret)
    {   
        ret = mraa_i2c_read_byte_data(internal_master_handle->i2c_context, reg_addr);
        (ret != -1) ? *data  = ret, ret = 0 : 0; 
    }

    pthread_spin_unlock(&internal_master_handle->handle_lock);

    return ret;

}

int I2Cmaster_read_bytes(uint8_t slave_addr, uint8_t reg_addr, uint8_t *data, size_t len)
{
    if(NULL == internal_master_handle)
    {
        return -1;
    }

    pthread_spin_lock(&internal_master_handle->handle_lock);

    mraa_result_t ret =  mraa_i2c_address(internal_master_handle->i2c_context, slave_addr);
    if(0 == ret)
    {   
        ret = mraa_i2c_read_bytes_data(internal_master_handle->i2c_context, reg_addr, data , len);
        (ret == len) ? ret = 0 : 0; 
    }

    pthread_spin_unlock(&internal_master_handle->handle_lock);

    return ret;
}

/**
 * @brief 
 * 
 * @file main_task.c
 * @author Gunj Manseta
 * @date 2018-03-09
 */

#include <pthread.h>
#include <fcntl.h>           /* For O_* constants */
#include <sys/stat.h>        /* For mode constants */
#include <mqueue.h>
#include <string.h>
#include <errno.h>
#include "main_task.h"
#include "error_data.h"
#include "logger_task.h"
#include "socket_task.h"
#include "light_sensor_task.h"
#include "temperature_sensor_task.h"
#include "my_signals.h"
#include "posixTimer.h"
#include "common_helper.h"
#include "readConfiguration.h"


#define MQ_MAINTASK_NAME "/maintask_queue"

volatile int timeoutflag;
volatile sig_atomic_t signal_exit;
volatile int aliveStatus[NUM_CHILD_THREADS] = {0};

void* (*thread_callbacks[NUM_CHILD_THREADS])(void *) =
{
    logger_task_callback,
    temperature_task_callback,
    socket_task_callback,
    light_task_callback,
};


static mqd_t maintask_q;

/**
 * @brief  Signal handler for the main task
 *         Should not include stdout log in the handler as it is not thread safe. Find an alternative for this
 *          Maybe use a global atomic type to set the signal type after cancelling all the thereads and check that 
 *          atomic data in the main_task after the join call if a signal occured and then use a stdout log there
 * 
 * @param signal 
 */
static void signal_handler(int signal)
{
	switch (signal)
	{

		case SIGUSR1:
			LOG_STDOUT(SIGNAL "SIGUSR1 signal.\n");
			break;
		case SIGUSR2:
			LOG_STDOUT(SIGNAL "SIGUSR2 signal.\n");
			break;
		case SIGINT:
			LOG_STDOUT(SIGNAL "SIGINT signal.\n");
			break;
		case SIGTERM:
			LOG_STDOUT(SIGNAL "SIGTERM signal.\n");
			break;
		case SIGTSTP:
			LOG_STDOUT(SIGNAL "SIGTSTP signal.\n");
			break;
		default:
			LOG_STDOUT(SIGNAL "Invalid signal.\n");
			break;
	}
    /* Cancelling all the threads for any signals */
    // for(int i = 0; i < NUM_CHILD_THREADS; i++)
    // {
    //     pthread_cancel(pthread_id[i]);
    // }

    signal_exit = 1;
}

/**
 * @brief Timer handler
 * 
 * @param sigval 
 */
static void timer_handler_setup(union sigval sig)
{		
    if(1 == timeoutflag)
    {
        LOG_STDOUT(ERROR "TIMEOUT. App could not be setup in time\n");
        timeoutflag=0;
        delete_timer(*(timer_t*)sig.sival_ptr);
        exit(1);
    }
}

static void timer_handler_aliveStatusCheck(union sigval sig)
{		
    if(!aliveStatus[LOGGER_TASK_ID] && !aliveStatus[LIGHT_TASK_ID] && !aliveStatus[TEMPERATURE_TASK_ID])
    {
        pthread_mutex_lock(&aliveState_lock);
        aliveStatus[LOGGER_TASK_ID]++;
        aliveStatus[LIGHT_TASK_ID]++;
        aliveStatus[TEMPERATURE_TASK_ID]++;
        pthread_mutex_unlock(&aliveState_lock);
        DEFINE_LOG_STRUCT(logstruct,LT_MSG_TASK_STATUS,MAIN_TASK_ID);
        DEFINE_LIGHT_STRUCT(lightstruct,LIGHT_MSG_TASK_STATUS,MAIN_TASK_ID)
        DEFINE_TEMP_STRUCT(tempstruct,TEMP_MSG_TASK_STATUS,MAIN_TASK_ID)
        POST_MESSAGE_LOGTASK(&logstruct,"Send Alive status");
        POST_MESSAGE_LIGHTTASK(&lightstruct);
        POST_MESSAGE_TEMPERATURETASK(&tempstruct);
    }
    else
    {
        LOG_STDOUT(ERROR "One of the task not alive\n");
        stop_timer(*(timer_t*)sig.sival_ptr);
        delete_timer(*(timer_t*)sig.sival_ptr);
        /* Cancelling all the threads for any signals */
        for(int i = 0; i < NUM_CHILD_THREADS; i++)
        {
            #ifdef VALUES
            LOG_STDOUT(INFO "Child thread cancelled: %d %s\n",i, getTaskIdentfierString(i));
            #endif
            if(pthread_cancel(pthread_id[i]))
                LOG_STDOUT(INFO "Child thread cancelled failed: %d\n",i);
        }
        #ifdef VALUES
        LOG_STDOUT(INFO "All child thread cancelled\n");
        #endif
        /* Signaling main task to quit */
        signal_exit = 1;
    }
}

mqd_t getHandle_MainTaskQueue()
{
    return maintask_q;
}

int main_task_init()
{
    struct mq_attr maintaskQ_attr = {
        .mq_msgsize = sizeof(MAINTASKQ_MSG_T),
        .mq_maxmsg = 32,
        .mq_flags = 0,
        .mq_curmsgs = 0
    };

    mq_unlink(MQ_MAINTASK_NAME);
    maintask_q = mq_open(MQ_MAINTASK_NAME, O_CREAT | O_RDWR, 0666, &maintaskQ_attr);

    return maintask_q;;
}

void main_task_processMsg()
{
    int ret,prio;
    MAINTASKQ_MSG_T queueData = {0};
    struct timespec recv_timeout = {0};
    while(!signal_exit)
    {
        memset(&queueData,0,sizeof(queueData));
        clock_gettime(CLOCK_REALTIME, &recv_timeout);
        recv_timeout.tv_sec += 2;
        ret = mq_timedreceive(maintask_q,(char*)&(queueData),sizeof(queueData),&prio,&recv_timeout);
        if(ERR == ret && ETIMEDOUT == errno)
        {
            continue;
        }
        if(ERR == ret)
        {
            LOG_STDOUT(ERROR "MAIN TASK:MQ_RECV:%s\n",strerror(errno));
            continue;
        }
        switch(queueData.msgID)
        {
            case(MT_MSG_STATUS_RSP):
                #ifdef STDOUT_ALIVE
                LOG_STDOUT(INFO "ALIVE:%s\n",getTaskIdentfierString(queueData.sourceID));
                #endif
                pthread_mutex_lock(&aliveState_lock);
                aliveStatus[queueData.sourceID]--;
                pthread_mutex_unlock(&aliveState_lock);
                break;
            default:
                LOG_STDOUT(INFO "Invalid Main task queue id\n");
                break;
        }
    }

    LOG_STDOUT(INFO "MAIN TASK GOT EXIT\n");

}

void POST_EXIT_MESSAGE_ALL()
{
    DEFINE_LOG_STRUCT(logstruct,LT_MSG_TASK_EXIT,MAIN_TASK_ID);
    DEFINE_LIGHT_STRUCT(lightstruct,LIGHT_MSG_TASK_EXIT,MAIN_TASK_ID)
    DEFINE_TEMP_STRUCT(tempstruct,TEMP_MSG_TASK_EXIT,MAIN_TASK_ID)
    POST_MESSAGE_LIGHTTASK_EXIT(&lightstruct);
    POST_MESSAGE_TEMPERATURETASK_EXIT(&tempstruct);
    POST_MESSAGE_LOGTASK_EXIT(&logstruct,"FIRE IN THE HOLE. EXIT EXIT!");
    pthread_cancel(pthread_id[SOCKET_TASK_ID]);
}

int main_task_entry()
{
    /* Making the timeout flag true, this should be unset=false within 5 sec else the timer checking the operation 
    will send a kill signal and the app will close
    This is to make sure that the barrier is passed within 5 secs. Extra safety feature which might not be neccessary at all.
    */
    timeoutflag = 1;
    signal_exit = 0;
    int ret = main_task_init();    
    if(-1 == ret)
    {
        LOG_STDOUT(ERROR "MAIN TASK INIT:%s\n",strerror(errno));
        return ret;
    }

    ret = configdata_setup();
    if(ret)
        LOG_STDOUT(ERROR "Could not setup data from config file\n");

    /* Mutex init */
    pthread_mutex_init(&aliveState_lock, NULL);

    /* Registering a timer for 5 sec to check that the barrier is passed */
    timer_t timer_id;
    if(ERR == register_and_start_timer(&timer_id, 2*MICROSEC, 1, timer_handler_setup, &timer_id))
    {
        // LOG_STDOUT(ERROR "Timer Error\n");
        return ERR;
    }

    /* Create a barrier for all the threads + the main task*/
    pthread_barrier_init(&tasks_barrier,NULL,NUM_CHILD_THREADS+1);

    struct sigaction sa;
    /*Registering the signal callback handler*/
	register_signalHandler(&sa,signal_handler, REG_SIG_ALL);

    /* Create all the child threads */
    for(int i = 0; i < NUM_CHILD_THREADS; i++)
    {
        ret = pthread_create(&pthread_id[i],NULL,thread_callbacks[i],NULL);
        if(ret != 0)
        {
            LOG_STDOUT(ERROR "Pthread create:%d:%s\n",i,strerror(errno));
            return ret;
        }
    }

    LOG_STDOUT(INFO "MAIN TASK INIT COMPLETED\n");
    pthread_barrier_wait(&tasks_barrier);

    /* Resetting the timeoutflag as we are pass the barrier */
    timeoutflag = 0;

    ret= stop_timer(timer_id);
    if(ERR == ret)
    {
        LOG_STDOUT(ERROR "MAIN TASK CANNOT STOP TIMER:%s\n",strerror(errno));
        return ERR;
    }

    ret == delete_timer(timer_id);
    if(ERR == ret)
    {
        LOG_STDOUT(ERROR "MAIN TASK CANNOT DELETE TIMER:%s\n",strerror(errno));
    }

    if(ERR == register_and_start_timer(&timer_id, 5*MICROSEC, 0 ,timer_handler_aliveStatusCheck, &timer_id))
    {
        // LOG_STDOUT(ERROR "Timer Start Error\n");
        return ERR;
    }
    /* Start message processing which is a blocking call */
    main_task_processMsg();

    delete_timer(timer_id);

    POST_EXIT_MESSAGE_ALL();
    
    for(int i = 0; i < NUM_CHILD_THREADS; i++)
    {
        int retThread = 0;
        //  LOG_STDOUT(INFO "Pthread JOIN:%d\n",i);
        ret = pthread_join(pthread_id[i],(void*)&retThread);
        //  LOG_STDOUT(INFO "ThreadID %d: Ret:%d\n",i,retThread);
        if(ret  != 0)
        {
            LOG_STDOUT(ERROR "Pthread join:%d:%s\n",i,strerror(errno));
            return ret;
        }
    }

    pthread_mutex_destroy(&aliveState_lock);
    
    configdata_flush();

    LOG_STDOUT(INFO "GOODBYE CRUEL WORLD!!!\n");

    return SUCCESS;
}

#include <sys/time.h>
#include <time.h>
#include <string.h>

#include "my_time.h"
#include "error_data.h"

#define GET_TIMEOFDAY(x,y)	gettimeofday(x,y)	//syscall(__sys_gettimeofday,x,y)

int get_time_string(char *timeString, const int len)
{
	struct timeval tv;
	//struct tm* ptm;
	char time_string[20] = {0};

 	/* Obtain the time of day using the system call */
	unsigned long ret = GET_TIMEOFDAY(&tv,NULL);
	if(ret != 0)
	{
		memset(timeString,0,len);
		return ERR;
	}
	snprintf(time_string,sizeof(time_string),"%ld.%ld",tv.tv_sec,tv.tv_usec);
	//ptm = localtime (&tv.tv_sec);
	/* Format the date and time. */
	//strftime (time_string, sizeof (time_string), "%Y-%m-%d %H:%M:%S", ptm);
	//strftime (time_string, sizeof (time_string), "%X", ptm);
    memcpy(timeString,time_string, len);
    
    return SUCCESS;
}
/**
 * @brief 
 * 
 * @param temp 
 * @param unit 
 * @return int 
 */

#include <string.h>
#include "my_i2c.h"
#include "tmp102_sensor.h"

const TMP102_CONFIG_REG_SETTINGS_T TMP102_CONFIG_DEFAULT = 
{
    .SD_MODE = 0,
    .TM_MODE = 0,
    .POL     = 0,
    .OS      = 0,
    .EM_MODE = 0,
    .CR      = 2
};

int TMP102_setmode_allDefault()
{
    int ret = TMP102_setMode_CR_4HZ_default();
    if(ret) return ret;
    ret = TMP102_setMode_SD_Continuous_default();
    if(ret) return ret;
    ret = TMP102_setMode_ALERT_ActiveLow_default();
    if(ret) return ret;
    ret = TMP102_setMode_TM_ComparatorMode_default();
    if(ret) return ret;
    ret = TMP102_setMode_EM_NormalMode_default();
    return ret;
}
int TMP102_setMode(TMP102_CONFIG_REG_SETTINGS_T config)
{
    int ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,*((uint16_t*)&config), 0);

    return ret;
}

int TMP102_setMode_SD_PowerSaving()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data |= (uint16_t)TMP102_CONFIG_SD; 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}
int TMP102_setMode_SD_Continuous_default()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data &= ~((uint16_t)TMP102_CONFIG_SD); 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;
}

int TMP102_setMode_TM_ComparatorMode_default()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data &= ~((uint16_t)TMP102_CONFIG_TM); 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}
int TMP102_setMode_TM_InterruptMode()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data |= (uint16_t)TMP102_CONFIG_TM; 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}
int TMP102_setMode_ALERT_ActiveLow_default()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data &= ~((uint16_t)TMP102_CONFIG_POL); 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}
int TMP102_setMode_ALERT_ActiveHigh()
{
    uint16_t config_data = 1;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data |= (uint16_t)TMP102_CONFIG_POL; 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}
int TMP102_setMode_EM_NormalMode_default()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data &= ~((uint16_t)TMP102_CONFIG_EM); 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;


}
int TMP102_setMode_EM_ExtendedMode()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data |= (uint16_t)TMP102_CONFIG_EM; 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}
int TMP102_setMode_CR_250mHZ()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data &= ~((uint16_t)TMP102_CONFIG_CR(3)); 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}
int TMP102_setMode_CR_1HZ()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data &= ~((uint16_t)TMP102_CONFIG_CR(3));
    config_data |= ((uint16_t)TMP102_CONFIG_CR(1)); 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}
int TMP102_setMode_CR_4HZ_default()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data &= ~((uint16_t)TMP102_CONFIG_CR(3));
    config_data |= ((uint16_t)TMP102_CONFIG_CR(2)); 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}

int TMP102_setMode_CR_8HZ()
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    config_data |= ((uint16_t)TMP102_CONFIG_CR(3)); 

    ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION, config_data, 0);

    return ret;

}
int TMP102_readMode_ALERT(uint8_t *al_bit)
{
    uint16_t config_data = 0;

     /* Reading the already configured values in the sensor */
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_CONFIGURATION,(uint8_t*)&config_data, sizeof(config_data));
    if(ret == -1)
        return ret;

    *al_bit = (config_data & ((uint16_t)TMP102_CONFIG_AL))>>13; 

    return ret;
}

int TMP102_write_Tlow(float tlow_C)
{
    if(tlow_C < -56.0f || tlow_C > 151.0f)
        tlow_C = 75.0f;
    
    tlow_C /= 0.0625;
    uint16_t tl;

    if(tlow_C > 0)
    {
        tl = ((uint16_t)tlow_C << 4);
        tl &= 0x7FFF;
    }
    else
    {
        tlow_C = -1 * tlow_C;
        tl = (uint16_t)tlow_C;
        tl = ~(tl) + 1;
        tl = tl << 4; 
    }  
    
    int ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_TLOW, tl, 0);
    if(ret == -1)
        return ret;

    #ifdef TEST_I2C
    uint16_t retTlow =0;
    ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_TLOW,(uint8_t*)&retTlow, sizeof(retTlow));
    if(ret == -1)
        return ret;
    
    assert(retTlow == tl);
    assert_int_equal(retTlow,tl);
    #endif
         
}

int TMP102_write_Thigh(float thigh_C)
{

    if(thigh_C < -56.0f || thigh_C > 151.0f)
        thigh_C = 80.0f;
    
    thigh_C /= 0.0625;
    uint16_t th;

    if(thigh_C > 0)
    {
        th = ((uint16_t)thigh_C << 4);
        th &= 0x7FFF;
    }
    else
    {
        thigh_C = -1 * thigh_C;
        th = (uint16_t)thigh_C;
        th = ~(th) + 1;
        th = th << 4; 
    }  
    
    int ret = I2Cmaster_write_word(TMP102_SLAVE_ADDR, TMP102_REG_TLOW, th, 0);
    if(ret == -1)
        return ret;

    #ifdef TEST_I2C
    uint16_t ret =0;
    ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_TLOW,(uint8_t*)&ret, sizeof(ret));
    if(ret == -1)
        return ret;
    
    assert(ret == th);
    assert_true(ret == th);
    #endif


}

int TMP102_read_Tlow(float *tlow_C)
{
    uint16_t tlow =0;

    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_TLOW,(uint8_t*)&tlow, sizeof(ret));
    if(ret == -1)
        return ret;

    if(tlow & 0x800)
    {
        tlow = (~tlow) + 1; 
        *tlow_C = (-1) * (float)tlow * 0.0625;
    }
    else
    {
        *tlow_C = ((float)tlow)*0.0625;
    }

    return ret;

}

int TMP102_read_Thigh(float *thigh_C)
{
    uint16_t thigh =0;

    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_TLOW,(uint8_t*)&thigh, sizeof(ret));
    if(ret == -1)
        return ret;

    if(thigh & 0x800)
    {
        thigh = (~thigh) + 1; 
        *thigh_C = (-1) * (float)thigh * 0.0625;
    }
    else
    {
        *thigh_C = ((float)thigh)*0.0625;
    }

    return ret;

}


int TMP102_getTemp(float *temp, TEMPERATURE_UNIT_T unit)
{
    uint8_t buff[2] = {0};
    int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, TMP102_REG_TEMPERATURE, buff, sizeof(buff));
    if(ret == -1)
        return ret;

    /* We get MSB(15:8) in buff[0] and LSB(7:4) in buff[1] */
    uint16_t temp_raw = (buff[0] << 4) | (buff[1] >> 4);
    if(temp_raw & 0x800)
    {
        temp_raw = (~temp_raw) + 1; 
        *temp = (-1) * (float)temp_raw * 0.0625;
    }
    else
    {
        *temp = ((float)temp_raw)*0.0625;
    }

    if(unit == FAHREN)
    {
        *temp = (*temp * 1.8) + 32;
    }
    else if(unit == KELVIN)
    {
        *temp += 273.15;
    }

    return ret;
}

uint16_t* TMP102_memDump()
{
    uint16_t *memdump = (uint16_t*)malloc(4*sizeof(uint16_t));
    if(NULL == memdump)
        return NULL;
        
    memset(memdump, 0 , 4);

    for(uint8_t i = 0 ; i < 0x4; i++)
    {      
        int ret = I2Cmaster_read_bytes(TMP102_SLAVE_ADDR, i , (uint8_t*)(memdump+i), sizeof(uint16_t));
        memdump[i] = (memdump[i]<<8) | (memdump[i]>>8);
        
        //float temp = (float)(memdump[i]>>4) * 0.0625;
        //printf(" - F:%.02f - ",temp);
    }

    return memdump;
}#include "my_signals.h"
#include "error_data.h"

int register_signalHandler(struct sigaction *sa, void (*handler)(int), REG_SIGNAL_FLAG_t signalMask)
{
	sa->sa_handler = handler;

	sa->sa_flags = SA_RESTART;

	sigfillset(&sa->sa_mask);

	int ret_error = 0;
	
	if ((signalMask & REG_SIG_USR1) && sigaction(SIGUSR1, sa, NULL) == -1) 
	{
		ret_error++;
		LOG_STDOUT(ERROR "Cannot handle SIGUSR1.\n");
	}

	if ((signalMask & REG_SIG_USR2) && sigaction(SIGUSR2, sa, NULL) == -1) 
	{
		ret_error++;
		LOG_STDOUT(ERROR "Cannot handle SIGUSR2.\n");
	}
	
	if ((signalMask & REG_SIG_INT) && sigaction(SIGINT, sa, NULL) == -1) 
	{
		ret_error++;
		LOG_STDOUT(ERROR "Cannot handle SIGINT.\n");
	}
	
	if ((signalMask & REG_SIG_TSTP) && sigaction(SIGTERM, sa, NULL) == -1) 
	{
		ret_error++;
		LOG_STDOUT(ERROR "Cannot handle SIGTERM.\n");
	}
	
	if ((signalMask & REG_SIG_TSTP) && sigaction(SIGTSTP, sa, NULL) == -1) 
	{
		ret_error++;
		LOG_STDOUT(ERROR "Cannot handle SIGTSTOP.\n");
	}

	return ret_error;
}
/**
 * @brief 
 * 
 * @file BB_Led.c
 * @author Gunj Manseta
 * @date 2018-03-10
 */

#include <stdlib.h>
#include <stdio.h>
#include "BB_Led.h"


#define ON "1"
#define OFF "0"


#define LED_COUNT   4
const char *const LEDPATH[LED_COUNT] =
{
    "/sys/class/leds/beaglebone:green:usr0/brightness",
    "/sys/class/leds/beaglebone:green:usr1/brightness",
    "/sys/class/leds/beaglebone:green:usr2/brightness",
    "/sys/class/leds/beaglebone:green:usr3/brightness"
};

int BB_LedON(USER_LED_T lednum)
{
    /* Forcefully using USR LED 1 */
    lednum = 1;
    if(lednum < 4)
    {
        FILE *led_fd = fopen(LEDPATH[lednum], "r+");
        if(led_fd)
        {
            fwrite(ON,1,1,led_fd);
            fclose(led_fd);
            return 0; 
        }   
        else
            return -1;
    }
    else
        return -1;

}

int BB_LedOFF(USER_LED_T lednum)
{
    /* Forcefully using USR LED 1 */
    lednum = 1;
    if(lednum < 4)
    {
        FILE *led_fd = fopen(LEDPATH[lednum], "r+");
        if(led_fd)
        {
            fwrite(OFF,1,1,led_fd);
            fclose(led_fd);
            return 0; 
        }   
        else
            return -1;
    }
    else
        return -1;

}

int BB_LedDefault()
{
    FILE *led_fd = fopen("/sys/class/leds/beaglebone:green:usr0/trigger", "r+");
    if(led_fd)
    {
        fwrite("heartbeat",1,sizeof("heartbeat"),led_fd);
        fclose(led_fd);
        return 0; 
    }   
    else
        return -1;
}#include "main_task.h"


int main()
{

    int ret = main_task_entry();

    return ret;  


}/**
 * @brief 
 * 
 * @file temperature_sensor_task.c
 * @author Gunj Manseta
 * @date 2018-03-11
 */

#include <pthread.h>
#include <fcntl.h>           /* For O_* constants */
#include <sys/stat.h>        /* For mode constants */
#include <mqueue.h>
#include <string.h>
#include <errno.h>

#include "main_task.h"
#include "logger_task.h"
#include "error_data.h"
#include "temperature_sensor_task.h"
#include "my_i2c.h"
#include "tmp102_sensor.h"
#include "common_helper.h"


#define MQ_TEMPERATURETASK_NAME "/temperaturetask_queue"

static mqd_t temperaturetask_q;

pthread_mutex_t tempChangeLock;

volatile static float latest_temperature;


float getTempTask_temperature()
{
    float temp;
    pthread_mutex_lock(&tempChangeLock);
    temp = latest_temperature;
    pthread_mutex_unlock(&tempChangeLock);
    return temp;
}

static void timer_handler_getAndUpdateTemperature(union sigval sig)
{
    float temperature;

    DEFINE_LOG_STRUCT(logtaskstruct,LT_MSG_LOG,TEMPERATURE_TASK_ID);

    int ret = TMP102_getTemp_Celcius(&temperature);
    if(ret == 0) 
    {
        #ifdef VALUES
        LOG_STDOUT(INFO "Celcius:%.03f\n",temperature);
        #endif

        #ifdef LOGVALUES
        POST_MESSAGE_LOGTASK(&logtaskstruct,INFO "Celcius:%.03f\n",temperature);
        #endif
    }
    else 
    {
        LOG_STDOUT(ERROR "Temperature Sensor Inactive\n");
        POST_MESSAGE_LOGTASK(&logtaskstruct,ERROR "Temperature Sensor Inactive\n");
        return;
    }
    
    pthread_mutex_lock(&tempChangeLock);
    latest_temperature = temperature;
    pthread_mutex_unlock(&tempChangeLock);
}

mqd_t getHandle_TemperatureTaskQueue()
{
    return temperaturetask_q;
}

/**
 * @brief 
 * 
 * @return int 
 */
int temperature_task_queue_init()
{
    struct mq_attr temperaturetaskQ_attr = {
        .mq_msgsize = sizeof(TEMPERATURETASKQ_MSG_T),
        .mq_maxmsg = 128,
        .mq_flags = 0,
        .mq_curmsgs = 0
    };

    mq_unlink(MQ_TEMPERATURETASK_NAME);
    temperaturetask_q = mq_open(MQ_TEMPERATURETASK_NAME, O_CREAT | O_RDWR, 0666, &temperaturetaskQ_attr);

    return temperaturetask_q;;
}

void temperature_task_processMsg()
{
    int ret,prio;
    TEMPERATURETASKQ_MSG_T queueData = {0};
    DEFINE_MAINTASK_STRUCT(maintaskRsp,MT_MSG_STATUS_RSP,TEMPERATURE_TASK_ID);
    DEFINE_LOG_STRUCT(logtaskstruct,LT_MSG_LOG,TEMPERATURE_TASK_ID);
    //struct timespec recv_timeout = {0};
    uint8_t continue_flag = 1;
    while(continue_flag)
    {
        memset(&queueData,0,sizeof(queueData));
        // clock_gettime(CLOCK_REALTIME, &recv_timeout);
        // recv_timeout.tv_sec += 3;
        // ret = mq_timedreceive(temperaturetask_q,(char*)&(queueData),sizeof(queueData),&prio, &recv_timeout);
        ret = mq_receive(temperaturetask_q,(char*)&(queueData),sizeof(queueData),&prio);
        if(ERR == ret)
        {
            LOG_STDOUT(ERROR "MQ_RECV:%s\n",strerror(errno));
            POST_MESSAGE_LOGTASK(&logtaskstruct,ERROR "MQ_RECV:%s\n",strerror(errno));
            continue;
        }
        switch(queueData.msgID)
        {
            case(TEMP_MSG_TASK_STATUS):
                /* Send back task alive response to main task */
                POST_MESSAGE_LOGTASK(&logtaskstruct,INFO "ALIVE STATUS by:%s\n",getTaskIdentfierString(queueData.sourceID));
                POST_MESSAGE_MAINTASK(&maintaskRsp, "Temperature sensor task Alive");
                break;
            case(TEMP_MSG_TASK_GET_TEMP):
                break;
            case(TEMP_MSG_TASK_READ_DATA):
                break;
            case(TEMP_MSG_TASK_WRITE_CMD):
                break;
            case(TEMP_MSG_TASK_POWERDOWN):
                break;
            case(TEMP_MSG_TASK_POWERUP):
                break;
            case(TEMP_MSG_TASK_EXIT):
                continue_flag = 0;
                LOG_STDOUT(INFO "Temperature Task Exit request from:%s\n",getTaskIdentfierString(queueData.sourceID));
                POST_MESSAGE_LOGTASK(&logtaskstruct,INFO "Temperature Task Exit request from:%s\n",getTaskIdentfierString(queueData.sourceID));
                break;
            default:
                break;
        }
    }

}

/**
 * @brief 
 * 
 * @param i2c 
 * @return int 
 */
int temperature_task_I2Cinit(I2C_MASTER_HANDLE_T *i2c)
{
    int ret = 0;
    if(ret = I2Cmaster_Init(i2c) !=0)
    {
        printErrorCode(ret);
        LOG_STDOUT(ERROR "[FAIL] I2C Master init failed\n"); 
    }

    return ret;
}

/**
 * @brief 
 * 
 * @param i2c 
 * @return int 
 */
int temperature_task_I2Cdeinit(I2C_MASTER_HANDLE_T *i2c)
{
    int ret = 0;
    ret = I2Cmaster_Destroy(i2c);
    if(ret !=0)
    {
        printErrorCode(ret);
        LOG_STDOUT(WARNING "I2C Master destroy failed\n"); 
    }

    return ret;
}

void* temperature_task_callback(void *threadparam)
{
    LOG_STDOUT(INFO "TEMPERATURE TASK STARTED\n");

    int ret = temperature_task_queue_init();
    if(ERR == ret)
    {
        LOG_STDOUT(ERROR "TEMPERATURE TASK INIT%s\n",strerror(errno));
        exit(ERR);
    }

    I2C_MASTER_HANDLE_T i2c;
    ret = temperature_task_I2Cinit(&i2c);
    if(ret)
    {
        LOG_STDOUT(ERROR "[FAIL] TEMPERATURE TASK SENSOR INIT:%s\n",strerror(errno));
        goto FAIL_EXIT_SENSOR;
        //exit(ERR);
    }

    if(ret == 0) {LOG_STDOUT(INFO "[OK] Sensor Test\n");}
    else {LOG_STDOUT(INFO "[FAIL] Sensor Test\n");}


    LOG_STDOUT(INFO "TEMPERATURE TASK INIT COMPLETED\n");
    pthread_barrier_wait(&tasks_barrier);

    /* Registering a timer for 2 sec to update the task temp copy by getting the temperature value from the sensor*/
    timer_t timer_id;
    if(ERR == register_and_start_timer(&timer_id, 2*MICROSEC, 0, timer_handler_getAndUpdateTemperature, &timer_id))
    {
        // LOG_STDOUT(ERROR "Timer Error\n");
        goto FAIL_EXIT;
    }

    /* Process Log queue msg which executes untill the log_task_end flag is set to true*/
    temperature_task_processMsg();


    ret = delete_timer(timer_id);
    if(ERR == ret)
    {
        LOG_STDOUT(ERROR "TEMPERATURE TASK DELETE TIMER:%s\n",strerror(errno));
        exit(1);
    }

FAIL_EXIT:
    ////* Commented the i2x deint as the light sensor task will deinit the handle. THe handle within the low level i2c is common for a master */
    temperature_task_I2Cdeinit(&i2c);

FAIL_EXIT_SENSOR:
    mq_close(temperaturetask_q);
    LOG_STDOUT(INFO "Temperature task exit.\n");
    return SUCCESS;
}